Index: src/tkj/android/homecontrol/mythmote/LocationDbAdapter.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/LocationDbAdapter.java	(revision 129)
+++ src/tkj/android/homecontrol/mythmote/LocationDbAdapter.java	(working copy)
@@ -1,188 +0,0 @@
-package tkj.android.homecontrol.mythmote;
-
-import android.app.AlertDialog;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.DialogInterface.OnClickListener;
-import android.database.Cursor;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-
-/**
- * Location database adapter. 
- */
-public class LocationDbAdapter {
-
-    public static final String KEY_NAME = "name";
-    public static final String KEY_ADDRESS = "address";
-    public static final String KEY_PORT = "port";
-    public static final String KEY_ROWID = "_id";
-
-    private static final String TAG = "LocationDbAdapter";
-    private DatabaseHelper mDbHelper;
-    private SQLiteDatabase mDb;
-    
-    /**
-     * Database creation sql statement
-     */
-    private static final String DATABASE_CREATE =
-            "create table frontends (_id integer primary key autoincrement, "
-                    + "name text not null, address text not null, port int);";
-
-    private static final String DATABASE_NAME = "mythmotedata";
-    private static final String DATABASE_TABLE = "frontends";
-    private static final int DATABASE_VERSION = 1;
-
-    private final Context mCtx;
-
-    private static class DatabaseHelper extends SQLiteOpenHelper {
-
-        DatabaseHelper(Context context) {
-            super(context, DATABASE_NAME, null, DATABASE_VERSION);
-        }
-
-        @Override
-        public void onCreate(SQLiteDatabase db) {
-
-            db.execSQL(DATABASE_CREATE);
-        }
-
-        @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            Log.w(TAG, "Upgrading database from version " + oldVersion + " to "
-                    + newVersion + ", which will destroy all old data");
-            db.execSQL("DROP TABLE IF EXISTS frontends");
-            onCreate(db);
-        }
-    }
-
-    /**
-     * Constructor - takes the context to allow the database to be
-     * opened/created
-     * 
-     * @param ctx the Context within which to work
-     */
-    public LocationDbAdapter(Context ctx) {
-        this.mCtx = ctx;
-    }
-
-    /**
-     * Open the notes database. If it cannot be opened, try to create a new
-     * instance of the database. If it cannot be created, throw an exception to
-     * signal the failure
-     * 
-     * @return this (self reference, allowing this to be chained in an
-     *         initialization call)
-     * @throws SQLException if the database could be neither opened or created
-     */
-    public LocationDbAdapter open() throws SQLException {
-        mDbHelper = new DatabaseHelper(mCtx);
-        mDb = mDbHelper.getWritableDatabase();
-        return this;
-    }
-    
-    public void close() {
-        mDbHelper.close();
-    }
-
-
-    /**
-     * Create a new note using the title and body provided. If the note is
-     * successfully created return the new rowId for that note, otherwise return
-     * a -1 to indicate failure.
-     * 
-     * @param title the title of the note
-     * @param body the body of the note
-     * @return rowId or -1 if failed
-     */
-    public long createFrontendLocation(String name, String address, int port) {
-        ContentValues initialValues = new ContentValues();
-        initialValues.put(KEY_NAME, name);
-        initialValues.put(KEY_ADDRESS, address);
-        initialValues.put(KEY_PORT, port);
-
-        return mDb.insert(DATABASE_TABLE, null, initialValues);
-    }
-
-    /**
-     * Delete the note with the given rowId
-     * 
-     * @param rowId id of note to delete
-     * @return true if deleted, false otherwise
-     */
-    public boolean deleteFrontendLocation(long rowId) {
-
-        return mDb.delete(DATABASE_TABLE, KEY_ROWID + "=" + rowId, null) > 0;
-    }
-
-    /**
-     * Return a Cursor over the list of all notes in the database
-     * 
-     * @return Cursor over all notes
-     */
-    public Cursor fetchAllFrontendLocations() {
-
-        return mDb.query(DATABASE_TABLE, new String[] {KEY_ROWID, KEY_NAME,
-                KEY_ADDRESS, KEY_PORT}, null, null, null, null, null);
-    }
-
-    /**
-     * Return a Cursor positioned at the note that matches the given rowId
-     * 
-     * @param rowId id of note to retrieve
-     * @return Cursor positioned to matching note, if found
-     */
-    public Cursor fetchFrontendLocation(long rowId)  {
-    	Cursor mCursor = null;
-    	try
-    	{
-    		mCursor =
-                mDb.query(true, DATABASE_TABLE, new String[] {KEY_ROWID,
-                        KEY_NAME, KEY_ADDRESS, KEY_PORT}, KEY_ROWID + "=" + rowId, null,
-                        null, null, null, null);
-	        if (mCursor != null) 
-	        {
-	            mCursor.moveToFirst();
-	        }
-    	}
-    	catch(SQLException e)
-    	{
-    		AlertDialog.Builder builder = new AlertDialog.Builder(mCtx);
-    		builder.setTitle("DataBase Error");
-    		builder.setMessage(e.getLocalizedMessage());
-    		builder.setNeutralButton(R.string.ok_str, new OnClickListener(){
-
-				public void onClick(DialogInterface dialog, int which) {
-					// TODO Auto-generated method stub
-					
-				}});
-    		
-    	}
-        return mCursor;
-
-    }
-
-    /**
-     * Update the note using the details provided. The note to be updated is
-     * specified using the rowId, and it is altered to use the title and body
-     * values passed in
-     * 
-     * @param rowId id of note to update
-     * @param title value to set note title to
-     * @param body value to set note body to
-     * @return true if the note was successfully updated, false otherwise
-     */
-    public boolean updateFrontendLocation(long rowId, String name, String address, int port) {
-        ContentValues args = new ContentValues();
-        args.put(KEY_NAME, name);
-        args.put(KEY_ADDRESS, address);
-        args.put(KEY_PORT, port);
-
-        int rows = mDb.update(DATABASE_TABLE, args, KEY_ROWID + "=" + rowId, null);
-        return rows > 0;
-    }
-}
-
Index: src/tkj/android/homecontrol/mythmote/LocationEditor.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/LocationEditor.java	(revision 129)
+++ src/tkj/android/homecontrol/mythmote/LocationEditor.java	(working copy)
@@ -1,5 +1,7 @@
 package tkj.android.homecontrol.mythmote;
 
+import tkj.android.homecontrol.mythmote.db.MythMoteDbHelper;
+import tkj.android.homecontrol.mythmote.db.MythMoteDbManager;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.DialogInterface;
@@ -12,180 +14,189 @@
 /*
  * Edits a FrontendLocation object
  * */
-public class LocationEditor extends Activity {
+public class LocationEditor extends Activity
+{
 
 	private FrontendLocation _location;
-	
-	public LocationEditor(){ }
+
+	public LocationEditor()
+	{
+	}
+
 	public LocationEditor(FrontendLocation location)
 	{
 		_location = location;
 	}
-	
-	
-	
-	/** Called when the activity is first created.*/
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-     
-        this.setContentView(this.getLayoutInflater().inflate(R.layout.locationeditor, null));
-        
-        this.setupSaveButtonEvent(R.id.ButtonLocationSave);
-        this.setupCancelButtonEvent(R.id.ButtonLocationCancel);
-        
-        int id = this.getIntent().getIntExtra(FrontendLocation.STR_ID, -1);
-        if(id != -1)
-        {
-        	this._location = new FrontendLocation();
-        	this._location.ID = id;
-        	this._location.Name = this.getIntent().getStringExtra(FrontendLocation.STR_NAME);
-        	this._location.Address = this.getIntent().getStringExtra(FrontendLocation.STR_ADDRESS);
-        	this._location.Port = this.getIntent().getIntExtra(FrontendLocation.STR_PORT, 6456);
-        	
-        	SetUiFromLocation();
-        }
-    }
-    
-    private void SetUiFromLocation()
-    {
+
+	/** Called when the activity is first created. */
+	@Override
+	public void onCreate(Bundle savedInstanceState)
+	{
+		super.onCreate(savedInstanceState);
+
+		this.setContentView(this.getLayoutInflater().inflate(
+				R.layout.locationeditor, null));
+
+		this.setupSaveButtonEvent(R.id.ButtonLocationSave);
+		this.setupCancelButtonEvent(R.id.ButtonLocationCancel);
+
+		int id = this.getIntent().getIntExtra(FrontendLocation.STR_ID, -1);
+		if (id != -1)
+		{
+			this._location = new FrontendLocation();
+			this._location.ID = id;
+			this._location.Name = this.getIntent().getStringExtra(
+					FrontendLocation.STR_NAME);
+			this._location.Address = this.getIntent().getStringExtra(
+					FrontendLocation.STR_ADDRESS);
+			this._location.Port = this.getIntent().getIntExtra(
+					FrontendLocation.STR_PORT, 6456);
+
+			SetUiFromLocation();
+		}
+	}
+
+	private void SetUiFromLocation()
+	{
 		this.SetName(this._location.Name);
 		this.SetAddress(this._location.Address);
 		this.SetPort(this._location.Port);
-    }
-    
-	
+	}
+
 	private boolean Save()
 	{
-		if(this._location == null)
+		if (this._location == null)
 			this._location = new FrontendLocation();
 		this._location.Name = this.GetName();
 		this._location.Address = this.GetAddress();
 		this._location.Port = this.GetPort();
-		
-		
+
 		AlertDialog.Builder builder = new AlertDialog.Builder(this);
 		builder.setTitle(R.string.error_input_str);
-		builder.setNeutralButton(R.string.ok_str, new DialogInterface.OnClickListener(){
+		builder.setNeutralButton(R.string.ok_str,
+				new DialogInterface.OnClickListener()
+				{
 
-			public void onClick(DialogInterface dialog, int which) {
-				// TODO Auto-generated method stub
-				
-			}});
-		if(this._location.Name.trim().equals(""))
+					public void onClick(DialogInterface dialog, int which)
+					{
+						// TODO Auto-generated method stub
+
+					}
+				});
+		if (this._location.Name.trim().equals(""))
 		{
 			builder.setMessage(R.string.error_invalid_name_str);
 			builder.show();
-		}
-		else if(this._location.Address.trim().equals(""))
+		} else if (this._location.Address.trim().equals(""))
 		{
 			builder.setMessage(R.string.error_invalid_address_str);
 			builder.show();
-		}
-		else
+		} else
 		{
-			//set default port if port was not set.
-			if(this._location.Port <= 0)
+			// set default port if port was not set.
+			if (this._location.Port <= 0)
 				this._location.Port = MythCom.DEFAULT_MYTH_PORT;
-			
-			LocationDbAdapter adapter = new LocationDbAdapter(this);
+
+			MythMoteDbManager adapter = new MythMoteDbManager(this);
 			adapter.open();
-			if(this._location.ID == -1)
+			if (this._location.ID == -1)
 			{
-				this._location.ID = (int) adapter.createFrontendLocation(this._location.Name, this._location.Address, this._location.Port);
-			}
-			else
+				this._location.ID = (int) adapter.createFrontendLocation(
+						this._location.Name, this._location.Address,
+						this._location.Port);
+			} else
 			{
-				return adapter.updateFrontendLocation(this._location.ID, this._location.Name, this._location.Address, this._location.Port);
+				return adapter.updateFrontendLocation(this._location.ID,
+						this._location.Name, this._location.Address,
+						this._location.Port);
 			}
 			adapter.close();
-			
+
 			return true;
 		}
-		
+
 		return false;
 	}
-	
+
 	private void SaveAndExit()
 	{
-		//only exit if save is successful.
-		if(Save())
+		// only exit if save is successful.
+		if (Save())
 			this.finish();
 	}
-	
-	
-	
+
 	private final String GetName()
 	{
 		return this.GetTextBoxText(R.id.EditTextLocationName);
 	}
-	
+
 	private final String GetAddress()
 	{
 		return this.GetTextBoxText(R.id.EditTextAddress);
 	}
-	
+
 	private final int GetPort()
 	{
 		try
 		{
 			return Integer.parseInt(this.GetTextBoxText(R.id.EditTextPort));
-		}
-		catch(NumberFormatException e)
+		} catch (NumberFormatException e)
 		{
 			return -1;
 		}
 	}
-	
+
 	private final void SetName(String name)
 	{
 		this.SetTextBoxText(R.id.EditTextLocationName, name);
 	}
-	
+
 	private final void SetAddress(String address)
 	{
 		this.SetTextBoxText(R.id.EditTextAddress, address);
 	}
-	
+
 	private final void SetPort(int port)
 	{
 		this.SetTextBoxText(R.id.EditTextPort, Integer.toString(port));
 	}
-	
+
 	private final String GetTextBoxText(int textBoxViewId)
 	{
-		final EditText text = (EditText)this.findViewById(textBoxViewId);
+		final EditText text = (EditText) this.findViewById(textBoxViewId);
 		return text.getText().toString();
 	}
-	
+
 	private final void SetTextBoxText(int textBoxViewId, String text)
 	{
-		final EditText textBox = (EditText)this.findViewById(textBoxViewId);
+		final EditText textBox = (EditText) this.findViewById(textBoxViewId);
 		textBox.setText(text);
 	}
-	
-	
+
 	private final void setupSaveButtonEvent(int buttonViewId)
-    {
-    	final Button button = (Button) this.findViewById(buttonViewId);
-	    button.setOnClickListener(new OnClickListener() {
-	        public void onClick(View v) {
-	            //save location and exit
-	        	SaveAndExit();
-	        }
-	    });
-    }
-	
+	{
+		final Button button = (Button) this.findViewById(buttonViewId);
+		button.setOnClickListener(new OnClickListener()
+		{
+			public void onClick(View v)
+			{
+				// save location and exit
+				SaveAndExit();
+			}
+		});
+	}
+
 	private final void setupCancelButtonEvent(int buttonViewId)
-    {
-    	final Button button = (Button) this.findViewById(buttonViewId);
-	    button.setOnClickListener(new OnClickListener() {
-	        public void onClick(View v) {
-	            //just exit
-	        	finish();
-	        }
-	    });
-    }
-	
-	
+	{
+		final Button button = (Button) this.findViewById(buttonViewId);
+		button.setOnClickListener(new OnClickListener()
+		{
+			public void onClick(View v)
+			{
+				// just exit
+				finish();
+			}
+		});
+	}
+
 }
Index: src/tkj/android/homecontrol/mythmote/MythCom.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/MythCom.java	(revision 129)
+++ src/tkj/android/homecontrol/mythmote/MythCom.java	(working copy)
@@ -19,76 +19,15 @@
 import android.widget.Toast;
 
 /** Class that handles network communication with mythtvfrontend **/
-public class MythCom {
+public class MythCom
+{
 
-	public interface StatusChangedEventListener extends EventListener {
-		
+	public interface StatusChangedEventListener extends EventListener
+	{
+
 		public void StatusChanged(String StatusMsg, int statusCode);
 	}
-	
-	public static final String JUMPPOINT_channelpriorities = "channelpriorities";    //- Channel Recording Priorities
-	public static final String JUMPPOINT_channelrecpriority = "channelrecpriority";   //- Channel Recording Priorities
-	public static final String JUMPPOINT_deletebox = "deletebox";          //- TV Recording Deletion
-	public static final String JUMPPOINT_deleterecordings = "deleterecordings";    //- TV Recording Deletion
-	public static final String JUMPPOINT_flixbrowse = "flixbrowse";           //- Netflix Browser
-	public static final String JUMPPOINT_flixhistory = "flixhistory";          //- Netflix History
-	public static final String JUMPPOINT_flixqueue = "flixqueue";            //- Netflix Queue
-	public static final String JUMPPOINT_guidegrid = "guidegrid";            //- Program Guide
-	public static final String JUMPPOINT_livetv = "livetv";              //- Live TV
-	public static final String JUMPPOINT_livetvinguide = "livetvinguide";        //- Live TV In Guide
-	public static final String JUMPPOINT_mainmenu = "mainmenu";             //- Main Menu
-	public static final String JUMPPOINT_managerecordings = "managerecordings";     //- Manage Recordings / Fix Conflicts
-	public static final String JUMPPOINT_manualbox = "manualbox";            //- Manual Record Scheduling
-	public static final String JUMPPOINT_manualrecording = "manualrecording";      //- Manual Record Scheduling
-	public static final String JUMPPOINT_musicplaylists = "musicplaylists";       //- Select music playlists
-	public static final String JUMPPOINT_mythgallery = "mythgallery";          //- MythGallery
-	public static final String JUMPPOINT_mythgame = "mythgame";             //- MythGame
-	public static final String JUMPPOINT_mythmovietime = "mythmovietime";        //- MythMovieTime
-	public static final String JUMPPOINT_mythnews = "mythnews";             //- MythNews
-	public static final String JUMPPOINT_mythvideo = "mythvideo";            //- MythVideo
-	public static final String JUMPPOINT_mythweather = "mythweather";          //- MythWeather
-	public static final String JUMPPOINT_playbackbox = "playbackbox";          //- TV Recording Playback
-	public static final String JUMPPOINT_playbackrecordings = "playbackrecordings";   //- TV Recording Playback
-	public static final String JUMPPOINT_playdvd = "playdvd";              //- Play DVD
-	public static final String JUMPPOINT_playmusic = "playmusic";            //- Play music
-	public static final String JUMPPOINT_previousbox = "previousbox";          //- Previously Recorded
-	public static final String JUMPPOINT_progfinder = "progfinder";           //- Program Finder
-	public static final String JUMPPOINT_programfinder = "programfinder";        //- Program Finder
-	public static final String JUMPPOINT_programguide = "programguide";         //- Program Guide
-	public static final String JUMPPOINT_programrecpriority = "programrecpriority";   //- Program Recording Priorities
-	public static final String JUMPPOINT_recordingpriorities = "recordingpriorities";  //- Program Recording Priorities
-	public static final String JUMPPOINT_ripcd = "ripcd";                //- Rip CD
-	public static final String JUMPPOINT_ripdvd = "ripdvd";               //- Rip DVD
-	public static final String JUMPPOINT_statusbox = "statusbox";            //- Status Screen
-	public static final String JUMPPOINT_videobrowser = "videobrowser";         //- Video Browser
-	public static final String JUMPPOINT_videogallery = "videogallery";         //- Video Gallery
-	public static final String JUMPPOINT_videolistings = "videolistings";        //- Video Listings
-	public static final String JUMPPOINT_videomanager = "videomanager";         //- Video Manager
-	public static final String JUMPPOINT_viewscheduled = "viewscheduled";        //- Manage Recordings / Fix Conflicts
-	public static final String JUMPPOINT_zoneminderconsole = "zoneminderconsole";    //- ZoneMinder Console
-	public static final String JUMPPOINT_zoneminderevents = "zoneminderevents";     //- ZoneMinder Events
-	public static final String JUMPPOINT_zoneminderliveview = "zoneminderliveview";   //- ZoneMinder Live View
-	
-	public static final String KEY_up = "up";
-	public static final String KEY_down = "down";
-	public static final String KEY_left = "left";
-	public static final String KEY_right = "right";
-	public static final String KEY_enter = "enter";
-	public static final String KEY_backspace = "backspace";
-	public static final String KEY_esc = "escape";
-	
-    public static final String VOLUME_DOWN = "[";
-    public static final String VOLUME_UP = "]";
-    public static final String VOLUME_MUTE = "|";
-    public static final String CH_RETURN = "h";
-	public static final String PLAY_CH_UP = "channel up";
-	public static final String PLAY_CH_DW = "channel down";
-	public static final String PLAY_STOP = "stop";
-	public static final String PLAY_PLAY = "speed normal";
-	public static final String PLAY_SEEK_FW = "seek forward";
-	public static final String PLAY_SEEK_BW = "seek backward";
-	public static final String EXIT = "exit";
-	
+
 	public static final int DEFAULT_MYTH_PORT = 6546;
 	public static final int SOCKET_TIMEOUT = 2000;
 	public static final int ENABLE_WIFI = 0;
@@ -97,11 +36,11 @@
 	public static final int STATUS_CONNECTED = 1;
 	public static final int STATUS_CONNECTING = 3;
 	public static final int STATUS_ERROR = 99;
-	
+
 	private static Timer _timer;
 	private static Socket _socket;
 	private static OutputStreamWriter _outputStream;
-	private static InputStreamReader  _inputStream;
+	private static InputStreamReader _inputStream;
 	private static Activity _parent;
 	private static ConnectivityManager _conMgr;
 	private static String _status;
@@ -109,7 +48,7 @@
 	private static int _tmpStatusCode;
 	private static StatusChangedEventListener _statusListener;
 	private static FrontendLocation _frontend;
-	
+
 	private final Handler mHandler = new Handler();
 	private final Runnable mSocketActionComplete = new Runnable()
 	{
@@ -117,25 +56,24 @@
 		{
 			setStatus(_tmpStatus, _tmpStatusCode);
 		}
-		
+
 	};
-	
-	/** TimerTask that probes the current connection for its mythtv screen.  **/
+
+	/** TimerTask that probes the current connection for its mythtv screen. **/
 	private final TimerTask timerTaskCheckStatus = new TimerTask()
 	{
-		//Run at every timer tick
-		public void run() 
+		// Run at every timer tick
+		public void run()
 		{
-			//only if socket is connected
-			if(IsConnected())
+			// only if socket is connected
+			if (IsConnected())
 			{
-				//set disconnected status if nothing is returned.
-				if(queryMythScreen() == null)
+				// set disconnected status if nothing is returned.
+				if (queryMythScreen() == null)
 				{
-					//_timer.cancel();
+					// _timer.cancel();
 					setStatus("Disconnected", STATUS_DISCONNECTED);
-				}
-				else
+				} else
 				{
 					setStatus(_frontend.Name + " - Connected", STATUS_CONNECTED);
 				}
@@ -143,267 +81,280 @@
 		}
 	};
 
-	
 	/** Parent activity is used to get context */
 	public MythCom(Activity parentActivity)
 	{
 		_parent = parentActivity;
-		_conMgr = (ConnectivityManager) _parent.getSystemService(Context.CONNECTIVITY_SERVICE);
+		_conMgr = (ConnectivityManager) _parent
+				.getSystemService(Context.CONNECTIVITY_SERVICE);
 		_timer = new Timer();
 		_timer.schedule(timerTaskCheckStatus, 5000, 5000);
 	}
-	
-	/** Connects to the given address and port. Any existing connection will be broken first **/
+
+	/**
+	 * Connects to the given address and port. Any existing connection will be
+	 * broken first
+	 **/
 	public void Connect(FrontendLocation frontend)
 	{
-			//disconnect before we connect
-			this.Disconnect();
-			
-			//set address and port
-			_frontend = frontend;
-			
-			//create toast for all to eat and enjoy
-			Toast toast = Toast.makeText(_parent.getApplicationContext(), R.string.attempting_to_connect_str, Toast.LENGTH_SHORT);
-			toast.setGravity(Gravity.CENTER, 0, 0);
-			toast.show();
+		// disconnect before we connect
+		this.Disconnect();
 
-			this.setStatus("Connecting", STATUS_CONNECTING);
-			
-			//create a socket connecting to the address on the requested port
-			this.connectSocket();
+		// set address and port
+		_frontend = frontend;
+
+		// create toast for all to eat and enjoy
+		Toast toast = Toast.makeText(_parent.getApplicationContext(),
+				R.string.attempting_to_connect_str, Toast.LENGTH_SHORT);
+		toast.setGravity(Gravity.CENTER, 0, 0);
+		toast.show();
+
+		this.setStatus("Connecting", STATUS_CONNECTING);
+
+		// create a socket connecting to the address on the requested port
+		this.connectSocket();
 	}
-	
+
 	/** Closes the socket if it exists and it is already connected **/
 	public void Disconnect()
 	{
 		try
 		{
-			//send exit if connected
-			if(this.IsConnected())
+			// send exit if connected
+			if (this.IsConnected())
 				this.sendData("exit\n");
-			
-			//check if output stream exists
-			if(_outputStream != null)
+
+			// check if output stream exists
+			if (_outputStream != null)
 			{
 				_outputStream.close();
 				_outputStream = null;
 			}
-			
-			//check if input stream exists
-			if(_inputStream != null)
+
+			// check if input stream exists
+			if (_inputStream != null)
 			{
-				//close input stream
+				// close input stream
 				_inputStream.close();
 				_inputStream = null;
 			}
-			
-			if(this.IsConnected())
+
+			if (this.IsConnected())
 				_socket.close();
-			if(_socket != null)
+			if (_socket != null)
 				_socket = null;
-		}
-		catch(IOException ex)
+		} catch (IOException ex)
 		{
 			this.setStatus("Disconnect I/O error", STATUS_ERROR);
 		}
 	}
-	
+
 	public void SendJumpCommand(String jumpPoint)
 	{
-		//send command data
+		// send command data
 		this.sendData(String.format("jump %s\n", jumpPoint));
 	}
-	
+
 	public void SendKey(String key)
 	{
-		//send command data
+		// send command data
 		this.sendData(String.format("key %s\n", key));
 	}
-	
+
 	public void SendKey(char key)
 	{
-		//send command data
+		// send command data
 		this.sendData(String.format("key %s\n", key));
 	}
-	
+
 	public void SendPlaybackCmd(String cmd)
 	{
-		//send command data
+		// send command data
 		this.sendData(String.format("play %s\n", cmd));
 	}
-	
+
 	public void SetOnStatusChangeHandler(StatusChangedEventListener listener)
 	{
 		_statusListener = listener;
 	}
-	
+
 	public String GetStatusStr()
 	{
 		return _status;
 	}
-	
+
 	public boolean IsNetworkReady()
 	{
-		if(_conMgr != null && _conMgr.getActiveNetworkInfo().isConnected())
+		if (_conMgr != null && _conMgr.getActiveNetworkInfo().isConnected())
 			return true;
 		return false;
 	}
-	
+
 	public boolean IsConnected()
 	{
-		if(_socket == null) return false;
-		
+		if (_socket == null)
+			return false;
+
 		return (!_socket.isClosed()) && _socket.isConnected();
 	}
 
-
-	
-	
-	
-	/** Connects _socket to _frontend using a separate thread  **/
+	/** Connects _socket to _frontend using a separate thread **/
 	private void connectSocket()
 	{
-		//create socket
+		// create socket
 		_socket = new Socket();
-		
+
 		Thread thread = new Thread()
 		{
 			public void run()
 			{
 				try
 				{
-					InetAddress address = java.net.InetAddress.getByName(_frontend.Address);
-					
-				//	int ipHash = address.hashCode();
-				// This check for a route to the host is failing since android SDK 1.6
-				//	if(_conMgr.requestRouteToHost(ConnectivityManager.TYPE_WIFI, ipHash))// || _conMgr.requestRouteToHost(ConnectivityManager.TYPE_MOBILE, ipHash)
-				//	{
-						_socket.connect(new InetSocketAddress(address, _frontend.Port), SOCKET_TIMEOUT);
-						_outputStream = new OutputStreamWriter(_socket.getOutputStream());
-						_inputStream = new InputStreamReader(_socket.getInputStream());
-						
-						//check if everything was connected OK
-						if(!_socket.isConnected() || _outputStream == null)
-						{
-							_tmpStatus = "Unknown error getting output stream.";
-							_tmpStatusCode = STATUS_ERROR;
-						}
-						else
-						{
-							_tmpStatus = _frontend.Name + " - Connected";
-							_tmpStatusCode = STATUS_CONNECTED;
-						}
-				//	}
-				//	else
-				//	{
-				//		_tmpStatus = "No route to host: " + _frontend.Address;
-				//		_tmpStatusCode = STATUS_ERROR;
-				//	}
-				}
-				catch (UnknownHostException e)
+					InetAddress address = java.net.InetAddress
+							.getByName(_frontend.Address);
+
+					// int ipHash = address.hashCode();
+					// This check for a route to the host is failing since
+					// android SDK 1.6
+					// if(_conMgr.requestRouteToHost(ConnectivityManager.TYPE_WIFI,
+					// ipHash))// ||
+					// _conMgr.requestRouteToHost(ConnectivityManager.TYPE_MOBILE,
+					// ipHash)
+					// {
+					_socket.connect(new InetSocketAddress(address,
+							_frontend.Port), SOCKET_TIMEOUT);
+					_outputStream = new OutputStreamWriter(
+							_socket.getOutputStream());
+					_inputStream = new InputStreamReader(
+							_socket.getInputStream());
+
+					// check if everything was connected OK
+					if (!_socket.isConnected() || _outputStream == null)
+					{
+						_tmpStatus = "Unknown error getting output stream.";
+						_tmpStatusCode = STATUS_ERROR;
+					} else
+					{
+						_tmpStatus = _frontend.Name + " - Connected";
+						_tmpStatusCode = STATUS_CONNECTED;
+					}
+					// }
+					// else
+					// {
+					// _tmpStatus = "No route to host: " + _frontend.Address;
+					// _tmpStatusCode = STATUS_ERROR;
+					// }
+				} catch (UnknownHostException e)
 				{
 					_tmpStatus = "Unknown host: " + _frontend.Address;
 					_tmpStatusCode = STATUS_ERROR;
-				}
-				catch (IOException e)
+				} catch (IOException e)
 				{
-					_tmpStatus = e.getLocalizedMessage() + ": " + _frontend.Address;
+					_tmpStatus = e.getLocalizedMessage() + ": "
+							+ _frontend.Address;
 					_tmpStatusCode = STATUS_ERROR;
 				}
-				
-				//post results
+
+				// post results
 				mHandler.post(mSocketActionComplete);
 			}
 		};
-		
-		//run thread
+
+		// run thread
 		thread.start();
 	}
-	
-	/** Sends data to the output stream of the socket.
-	 * Attempts to reconnect socket if connection does not already exist. **/
+
+	/**
+	 * Sends data to the output stream of the socket. Attempts to reconnect
+	 * socket if connection does not already exist.
+	 **/
 	private void sendData(String data)
 	{
-		if(this.IsConnected() && _outputStream != null)
+		if (this.IsConnected() && _outputStream != null)
 		{
 			try
 			{
-				if(!data.endsWith("\n")) 
+				if (!data.endsWith("\n"))
 					data = String.format("%s\n", data);
-				
+
 				_outputStream.write(data);
 				_outputStream.flush();
-			}
-			catch (IOException e)
+			} catch (IOException e)
 			{
 				this.setStatus("I/O Error data", STATUS_ERROR);
 			}
 		}
 	}
-	
-	/** Reads data from the input stream of the socket.
-	 * Returns null if no data in received **/
+
+	/**
+	 * Reads data from the input stream of the socket. Returns null if no data
+	 * in received
+	 **/
 	private char[] readData()
 	{
-		if(this.IsConnected() && _inputStream != null )
+		if (this.IsConnected() && _inputStream != null)
 		{
 			char[] buf = new char[100];
-			try 
+			try
 			{
-				if(_inputStream.ready())
+				if (_inputStream.ready())
 				{
 					int len = _inputStream.read(buf);
-					if(len > 0)
+					if (len > 0)
 						return buf;
 				}
-			} 
-			catch (IOException e) 
+			} catch (IOException e)
 			{
 				// TODO Auto-generated catch block
 				e.printStackTrace();
 			}
 		}
-		//return null if no data was received
+		// return null if no data was received
 		return null;
 	}
-	
+
 	/** Sets _status and fires the StatusChanged event **/
 	private void setStatus(final String StatusMsg, final int code)
 	{
-		_parent.runOnUiThread(new Runnable(){
+		_parent.runOnUiThread(new Runnable()
+		{
 
-			public void run() 
+			public void run()
 			{
 				_status = StatusMsg;
-				if(_statusListener != null)
+				if (_statusListener != null)
 					_statusListener.StatusChanged(StatusMsg, code);
 			}
-			
+
 		});
 	}
-	
-	/** Returns the string representation of the current mythfrontend
-	 * screen location. Returns null on error **/
+
+	/**
+	 * Returns the string representation of the current mythfrontend screen
+	 * location. Returns null on error
+	 **/
 	private String queryMythScreen()
 	{
-		//send query location command
+		// send query location command
 		this.sendData("query location");
-		
-		//read input stream
+
+		// read input stream
 		char[] data = this.readData();
-		
-		if(data != null && data.length > 0)
+
+		if (data != null && data.length > 0)
 		{
 			return data.toString();
-		}
-		else
+		} else
 		{
-			//we're not receiving data the other 
-			//end must have disconnected
+			// we're not receiving data the other
+			// end must have disconnected
 			return null;
 		}
 	}
 
+	public void SendCommand(String command)
+	{
+		this.sendData(String.format("%s\n", command));
+	}
 
-	
 }
Index: src/tkj/android/homecontrol/mythmote/keymanager/KeyBindingEntry.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/keymanager/KeyBindingEntry.java	(revision 0)
+++ src/tkj/android/homecontrol/mythmote/keymanager/KeyBindingEntry.java	(revision 0)
@@ -0,0 +1,60 @@
+package tkj.android.homecontrol.mythmote.keymanager;
+
+import tkj.android.homecontrol.mythmote.keymanager.KeyBindingManager.MythKey;
+
+/**
+ * Simple holder class to associate (at run time) a key with the myth command to
+ * execute
+ * 
+ * @author rob elsner
+ * 
+ */
+public class KeyBindingEntry
+{
+
+	/**
+	 * The user shown name of this key, for editing
+	 */
+	private String friendlyName;
+	/**
+	 * The binding entry
+	 */
+	private MythKey mythKey;
+
+	/**
+	 * The myth command we should send
+	 */
+	private String command;
+
+	private boolean requiresConfirmation = false;
+
+	public KeyBindingEntry(final String friendlyName, final MythKey mythKey,
+			final String command, final boolean requiresConfirm)
+	{
+		this.command = command;
+		this.mythKey = mythKey;
+		this.friendlyName = friendlyName;
+		this.requiresConfirmation = requiresConfirm;
+	}
+
+	public String getFriendlyName()
+	{
+		return friendlyName;
+	}
+
+	public MythKey getMythKey()
+	{
+		return mythKey;
+	}
+
+	public String getCommand()
+	{
+		return command;
+	}
+
+	public boolean requiresConfirmation()
+	{
+		return requiresConfirmation;
+	}
+
+}
Index: src/tkj/android/homecontrol/mythmote/keymanager/KeyMapBinder.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/keymanager/KeyMapBinder.java	(revision 0)
+++ src/tkj/android/homecontrol/mythmote/keymanager/KeyMapBinder.java	(revision 0)
@@ -0,0 +1,8 @@
+package tkj.android.homecontrol.mythmote.keymanager;
+
+import android.view.View;
+
+public interface KeyMapBinder
+{
+	public View bind(final KeyBindingEntry entry);
+}
Index: src/tkj/android/homecontrol/mythmote/keymanager/KeyBindingManager.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/keymanager/KeyBindingManager.java	(revision 0)
+++ src/tkj/android/homecontrol/mythmote/keymanager/KeyBindingManager.java	(revision 0)
@@ -0,0 +1,293 @@
+package tkj.android.homecontrol.mythmote.keymanager;
+
+import static tkj.android.homecontrol.mythmote.R.id.Button0;
+import static tkj.android.homecontrol.mythmote.R.id.Button1;
+import static tkj.android.homecontrol.mythmote.R.id.Button2;
+import static tkj.android.homecontrol.mythmote.R.id.Button3;
+import static tkj.android.homecontrol.mythmote.R.id.Button4;
+import static tkj.android.homecontrol.mythmote.R.id.Button5;
+import static tkj.android.homecontrol.mythmote.R.id.Button6;
+import static tkj.android.homecontrol.mythmote.R.id.Button7;
+import static tkj.android.homecontrol.mythmote.R.id.Button8;
+import static tkj.android.homecontrol.mythmote.R.id.Button9;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonBackspace;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonChDown;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonChReturn;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonChUp;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonDown;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonEnter;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonEsc;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonFF;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonGuide;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonInfo;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonJump1;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonJump2;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonJump3;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonJump4;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonJump5;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonJump6;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonLeft;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonMenu;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonMute;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonPause;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonPlay;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonRecord;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonRew;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonRight;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonSelect;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonSkipBack;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonSkipForward;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonStop;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonUp;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonVolDown;
+import static tkj.android.homecontrol.mythmote.R.id.ButtonVolUp;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import tkj.android.homecontrol.mythmote.MythCom;
+import tkj.android.homecontrol.mythmote.db.MythMoteDbManager;
+
+import android.content.Context;
+import android.util.Log;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnLongClickListener;
+
+public class KeyBindingManager implements KeyMapBinder, OnClickListener,
+		OnLongClickListener
+{
+
+	/**
+	 * Add a value here which is the button name (preferably similar to the
+	 * layout id) and the default action
+	 * 
+	 * @author robelsner
+	 * 
+	 */
+	public enum MythKey
+	{
+		BUTTON_0("key 0", Button0),
+		BUTTON_1("key 1", Button1),
+		BUTTON_2("key 2", Button2),
+		BUTTON_3("key 3", Button3),
+		BUTTON_4("key 4", Button4),
+		BUTTON_5("key 5", Button5),
+		BUTTON_6("key 6", Button6),
+		BUTTON_7("key 7", Button7),
+		BUTTON_8("key 8", Button8),
+		BUTTON_9("key 9", Button9),
+		BUTTON_BACKSPACE("key backspace", ButtonBackspace),
+		BUTTON_CHANNEL_DOWN("play channel down", ButtonChDown),
+		BUTTON_CHANNEL_UP("play channel up", ButtonChUp),
+		BUTTON_CHANNEL_RECALL("key h", ButtonChReturn),
+		BUTTON_ESCAPE("key escape", ButtonEsc),
+		BUTTON_ENTER("key enter", ButtonEnter),
+		BUTTON_RECORD("key r", ButtonRecord),
+		BUTTON_STOP("play stop", ButtonStop),
+		BUTTON_PLAY("play speed normal", ButtonPlay),
+		BUTTON_PAUSE("play speed pause", ButtonPause),
+		BUTTON_DOWN("key down", ButtonDown),
+		BUTTON_UP("key up", ButtonUp),
+		BUTTON_LEFT("key left", ButtonLeft),
+		BUTTON_RIGHT("key right", ButtonRight),
+		BUTTON_SELECT("key enter", ButtonSelect),
+		BUTTON_FAST_FORWARD("play seek forward", ButtonFF),
+		BUTTON_REWIND("play seek backward", ButtonRew),
+		BUTTON_SKIP_FORWARD("key end", ButtonSkipForward),
+		BUTTON_SKIP_BACKWARD("key home", ButtonSkipBack),
+		BUTTON_GUIDE("key s", ButtonGuide),
+		BUTTON_INFO("key i", ButtonInfo),
+		BUTTON_JUMP_1("jump mainmenu", ButtonJump1),
+		BUTTON_JUMP_2("jump livetv", ButtonJump2),
+		BUTTON_JUMP_3("jump playbackrecordings", ButtonJump3),
+		BUTTON_JUMP_4("jump playmusic", ButtonJump4),
+		BUTTON_JUMP_5("jump videogallery", ButtonJump5),
+		BUTTON_JUMP_6("jump statusbox", ButtonJump6),
+		BUTTON_MENU("key m", ButtonMenu),
+		BUTTON_MUTE("key |", ButtonMute),
+		BUTTON_VOLUME_UP("key ]", ButtonVolUp),
+		BUTTON_VOLUME_DOWN("key [", ButtonVolDown);
+		
+		private final String defaultCommand;
+		private final int layoutId;
+
+		private MythKey(final String command, final int layoutId)
+		{
+			this.defaultCommand = command;
+			this.layoutId = layoutId;
+		}
+
+		public final String getDefaultCommand()
+		{
+			return defaultCommand;
+		}
+
+		public final int getButtonId()
+		{
+			return layoutId;
+		}
+
+		public static MythKey getByName(final String name)
+		{
+			for (MythKey key : MythKey.values())
+			{
+				if (key.name().equals(name))
+					return key;
+			}
+			return MythKey.BUTTON_0;
+		}
+
+		public static List<KeyBindingEntry> createDefaultList()
+		{
+			ArrayList<KeyBindingEntry> entries = new ArrayList<KeyBindingEntry>();
+			entries.add(new KeyBindingEntry("0", BUTTON_0,
+					BUTTON_0.defaultCommand, false));
+			entries.add(new KeyBindingEntry("1", BUTTON_1,
+					BUTTON_1.defaultCommand, false));
+			entries.add(new KeyBindingEntry("2", BUTTON_2,
+					BUTTON_2.defaultCommand, false));
+			entries.add(new KeyBindingEntry("3", BUTTON_3,
+					BUTTON_3.defaultCommand, false));
+			entries.add(new KeyBindingEntry("4", BUTTON_4,
+					BUTTON_4.defaultCommand, false));
+			entries.add(new KeyBindingEntry("5", BUTTON_5,
+					BUTTON_5.defaultCommand, false));
+			entries.add(new KeyBindingEntry("6", BUTTON_6,
+					BUTTON_6.defaultCommand, false));
+			entries.add(new KeyBindingEntry("7", BUTTON_7,
+					BUTTON_7.defaultCommand, false));
+			entries.add(new KeyBindingEntry("8", BUTTON_8,
+					BUTTON_8.defaultCommand, false));
+			entries.add(new KeyBindingEntry("9", BUTTON_9,
+					BUTTON_9.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Backspace", BUTTON_BACKSPACE,
+					BUTTON_BACKSPACE.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Down", BUTTON_CHANNEL_DOWN,
+					BUTTON_CHANNEL_DOWN.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Up", BUTTON_CHANNEL_UP,
+					BUTTON_CHANNEL_UP.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Recall", BUTTON_CHANNEL_RECALL,
+					BUTTON_CHANNEL_RECALL.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Esc", BUTTON_ESCAPE,
+					BUTTON_ESCAPE.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Enter", BUTTON_ENTER,
+					BUTTON_ENTER.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Rec", BUTTON_RECORD,
+					BUTTON_RECORD.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Stop", BUTTON_STOP,
+					BUTTON_STOP.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Play", BUTTON_PLAY,
+					BUTTON_PLAY.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Pause", BUTTON_PAUSE,
+					BUTTON_PAUSE.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Down", BUTTON_DOWN,
+					BUTTON_DOWN.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Up", BUTTON_UP,
+					BUTTON_UP.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Left", BUTTON_LEFT,
+					BUTTON_LEFT.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Right", BUTTON_RIGHT,
+					BUTTON_RIGHT.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Select", BUTTON_SELECT,
+					BUTTON_SELECT.defaultCommand, false));
+			entries.add(new KeyBindingEntry("FF", BUTTON_FAST_FORWARD,
+					BUTTON_FAST_FORWARD.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Rew", BUTTON_REWIND,
+					BUTTON_REWIND.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Start", BUTTON_SKIP_BACKWARD,
+					BUTTON_SKIP_BACKWARD.defaultCommand, false));
+			entries.add(new KeyBindingEntry("End", BUTTON_SKIP_FORWARD,
+					BUTTON_SKIP_FORWARD.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Guide", BUTTON_GUIDE,
+					BUTTON_GUIDE.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Info", BUTTON_INFO,
+					BUTTON_INFO.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Main", BUTTON_JUMP_1,
+					BUTTON_JUMP_1.defaultCommand, false));
+			entries.add(new KeyBindingEntry("TV", BUTTON_JUMP_2,
+					BUTTON_JUMP_2.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Recordings", BUTTON_JUMP_3,
+					BUTTON_JUMP_3.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Music", BUTTON_JUMP_4,
+					BUTTON_JUMP_4.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Videos", BUTTON_JUMP_5,
+					BUTTON_JUMP_5.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Status", BUTTON_JUMP_6,
+					BUTTON_JUMP_6.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Menu", BUTTON_MENU,
+					BUTTON_MENU.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Mute", BUTTON_MUTE,
+					BUTTON_MUTE.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Vol Up", BUTTON_VOLUME_UP,
+					BUTTON_VOLUME_UP.defaultCommand, false));
+			entries.add(new KeyBindingEntry("Vol Down", BUTTON_VOLUME_DOWN,
+					BUTTON_VOLUME_DOWN.defaultCommand, false));
+			return entries;
+		}
+	}
+
+	private KeyMapBinder binder = null;
+
+	private Map<View, KeyBindingEntry> viewToEntryMap = new HashMap<View, KeyBindingEntry>();
+
+	private MythCom communicator;
+
+	private MythMoteDbManager databaseAdapter;
+
+	public KeyBindingManager(final Context ctx, final KeyMapBinder binder,
+			final MythCom communicator)
+	{
+		Log.d("KBM", "Created KeyBindingManager with ctx " + ctx + " binder "
+				+ binder + " comm " + communicator);
+		this.databaseAdapter = new MythMoteDbManager(ctx);
+
+		this.binder = binder;
+		this.communicator = communicator;
+
+	}
+
+	public void loadKeys()
+	{
+		Log.d("KBM", "loadKeys with dba " + databaseAdapter);
+		databaseAdapter.open();
+		databaseAdapter.loadKeyMapEntries(this);
+		databaseAdapter.close();
+	}
+
+	public View bind(KeyBindingEntry entry)
+	{
+		Log.d("KBM",
+				"Bind " + entry.getFriendlyName() + " to " + entry.getCommand());
+		View v = binder.bind(entry);
+		viewToEntryMap.put(v, entry);
+		return v;
+	}
+
+	public KeyBindingEntry getCommand(final View initiatingView)
+	{
+		return viewToEntryMap.get(initiatingView);
+	}
+
+	public void onClick(View v)
+	{
+
+		KeyBindingEntry entry = viewToEntryMap.get(v);
+
+		if (null != entry && null != communicator)
+		{
+			Log.d("KBM", "onClick " + entry.getFriendlyName());
+			communicator.SendCommand(entry.getCommand());
+		}
+
+	}
+
+	public boolean onLongClick(View v)
+	{
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+}
Index: src/tkj/android/homecontrol/mythmote/db/MythMoteDbManager.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/db/MythMoteDbManager.java	(revision 0)
+++ src/tkj/android/homecontrol/mythmote/db/MythMoteDbManager.java	(revision 0)
@@ -0,0 +1,229 @@
+package tkj.android.homecontrol.mythmote.db;
+
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.FRONTEND_TABLE;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_COMMAND;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_FRIENDLY_NAME;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_REQUIRE_CONFIRMATION;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_ROWID;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_UI_KEY;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEY_ADDRESS;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEY_BINDINGS_TABLE;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEY_NAME;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEY_PORT;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEY_ROWID;
+import tkj.android.homecontrol.mythmote.R;
+import tkj.android.homecontrol.mythmote.keymanager.KeyBindingEntry;
+import tkj.android.homecontrol.mythmote.keymanager.KeyBindingManager.MythKey;
+import tkj.android.homecontrol.mythmote.keymanager.KeyMapBinder;
+import android.app.AlertDialog;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+public class MythMoteDbManager
+{
+	private static final String TAG = "MythMoteDbManager";
+
+	private SQLiteDatabase db;
+	private MythMoteDbHelper dbHelper;
+	private final Context context;
+
+	public MythMoteDbManager(final Context ctx)
+	{
+		this.context = ctx;
+	}
+
+	public void open()
+	{
+		this.dbHelper = new MythMoteDbHelper(context);
+		this.db = this.dbHelper.getWritableDatabase();
+	}
+
+	public void close()
+	{
+		dbHelper.close();
+	}
+
+	/**
+	 * Create a new note using the title and body provided. If the note is
+	 * successfully created return the new rowId for that note, otherwise return
+	 * a -1 to indicate failure.
+	 * 
+	 * @param title
+	 *            the title of the note
+	 * @param body
+	 *            the body of the note
+	 * @return rowId or -1 if failed
+	 */
+	public long createFrontendLocation(String name, String address, int port)
+	{
+		ContentValues initialValues = new ContentValues();
+		initialValues.put(KEY_NAME, name);
+		initialValues.put(KEY_ADDRESS, address);
+		initialValues.put(KEY_PORT, port);
+
+		return db.insert(FRONTEND_TABLE, null, initialValues);
+	}
+
+	/**
+	 * Delete the note with the given rowId
+	 * 
+	 * @param rowId
+	 *            id of note to delete
+	 * @return true if deleted, false otherwise
+	 */
+	public boolean deleteFrontendLocation(long rowId)
+	{
+
+		return db.delete(FRONTEND_TABLE, KEY_ROWID + "=" + rowId, null) > 0;
+	}
+
+	/**
+	 * Return a Cursor over the list of all notes in the database
+	 * 
+	 * @return Cursor over all notes
+	 */
+	public Cursor fetchAllFrontendLocations()
+	{
+
+		return db.query(FRONTEND_TABLE, new String[]
+		{ KEY_ROWID, KEY_NAME, KEY_ADDRESS, KEY_PORT }, null, null, null, null,
+				null);
+	}
+
+	/**
+	 * Return a Cursor positioned at the note that matches the given rowId
+	 * 
+	 * @param rowId
+	 *            id of note to retrieve
+	 * @return Cursor positioned to matching note, if found
+	 */
+	public Cursor fetchFrontendLocation(long rowId)
+	{
+		Cursor mCursor = null;
+		try
+		{
+			mCursor = db.query(true, FRONTEND_TABLE, new String[]
+			{ KEY_ROWID, KEY_NAME, KEY_ADDRESS, KEY_PORT }, KEY_ROWID + "="
+					+ rowId, null, null, null, null, null);
+			if (mCursor != null)
+			{
+				mCursor.moveToFirst();
+			}
+		} catch (SQLException e)
+		{
+			AlertDialog.Builder builder = new AlertDialog.Builder(context);
+			builder.setTitle("DataBase Error");
+			builder.setMessage(e.getLocalizedMessage());
+			builder.setNeutralButton(R.string.ok_str, new OnClickListener()
+			{
+
+				public void onClick(DialogInterface dialog, int which)
+				{
+					// TODO Auto-generated method stub
+
+				}
+			});
+
+		}
+		return mCursor;
+
+	}
+
+	/**
+	 * Update the note using the details provided. The note to be updated is
+	 * specified using the rowId, and it is altered to use the title and body
+	 * values passed in
+	 * 
+	 * @param rowId
+	 *            id of note to update
+	 * @param title
+	 *            value to set note title to
+	 * @param body
+	 *            value to set note body to
+	 * @return true if the note was successfully updated, false otherwise
+	 */
+	public boolean updateFrontendLocation(long rowId, String name,
+			String address, int port)
+	{
+		ContentValues args = new ContentValues();
+		args.put(KEY_NAME, name);
+		args.put(KEY_ADDRESS, address);
+		args.put(KEY_PORT, port);
+
+		int rows = db.update(FRONTEND_TABLE, args, KEY_ROWID + "=" + rowId,
+				null);
+		return rows > 0;
+	}
+
+	public boolean save(final KeyBindingEntry entry)
+	{
+		ContentValues values = new ContentValues();
+		values.put(KEYBINDINGS_COMMAND, entry.getCommand());
+		values.put(KEYBINDINGS_UI_KEY, entry.getMythKey().name());
+		values.put(KEYBINDINGS_FRIENDLY_NAME, entry.getFriendlyName());
+		values.put(KEYBINDINGS_REQUIRE_CONFIRMATION,
+				entry.requiresConfirmation() ? 1 : 0);
+		Log.d("KBDA", "Adding entry " + entry.getFriendlyName() + " to "
+				+ entry.getCommand());
+		return db.insert(KEY_BINDINGS_TABLE, null, values) != -1;
+	}
+
+	public void loadKeyMapEntries(final KeyMapBinder binder)
+	{
+		Cursor mCursor = null;
+		try
+		{
+			mCursor = db.query(true, KEY_BINDINGS_TABLE,
+					new String[]
+					{ KEYBINDINGS_ROWID, KEYBINDINGS_COMMAND,
+							KEYBINDINGS_UI_KEY, KEYBINDINGS_FRIENDLY_NAME,
+							KEYBINDINGS_REQUIRE_CONFIRMATION }, null, null,
+					null, null, null, null);
+			if (mCursor != null)
+			{
+				mCursor.moveToFirst();
+			}
+		} catch (SQLException e)
+		{
+			AlertDialog.Builder builder = new AlertDialog.Builder(context);
+			builder.setTitle("DataBase Error");
+			builder.setMessage(e.getLocalizedMessage());
+			builder.setNeutralButton(R.string.ok_str, new OnClickListener()
+			{
+
+				public void onClick(DialogInterface dialog, int which)
+				{
+					// TODO Auto-generated method stub
+
+				}
+			});
+
+		}
+		if (null == mCursor)
+			return;
+		do
+		{
+			String friendlyName = mCursor.getString(mCursor
+					.getColumnIndex(KEYBINDINGS_FRIENDLY_NAME));
+			String mythKeyName = mCursor.getString(mCursor
+					.getColumnIndex(KEYBINDINGS_UI_KEY));
+			String command = mCursor.getString(mCursor
+					.getColumnIndex(KEYBINDINGS_COMMAND));
+			Integer req = mCursor.getInt(mCursor
+					.getColumnIndex(KEYBINDINGS_REQUIRE_CONFIRMATION));
+			MythKey mythKey = MythKey.getByName(mythKeyName);
+			boolean requiresConfirmation = (req == 1);
+			KeyBindingEntry entry = new KeyBindingEntry(friendlyName, mythKey,
+					command, requiresConfirmation);
+			binder.bind(entry);
+		} while (mCursor.moveToNext());
+		mCursor.close();
+	}
+
+}
Index: src/tkj/android/homecontrol/mythmote/db/MythMoteDbHelper.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/db/MythMoteDbHelper.java	(revision 0)
+++ src/tkj/android/homecontrol/mythmote/db/MythMoteDbHelper.java	(revision 0)
@@ -0,0 +1,101 @@
+package tkj.android.homecontrol.mythmote.db;
+
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_COMMAND;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_FRIENDLY_NAME;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEY_BINDINGS_TABLE;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_REQUIRE_CONFIRMATION;
+import static tkj.android.homecontrol.mythmote.db.MythMoteDbHelper.KEYBINDINGS_UI_KEY;
+import tkj.android.homecontrol.mythmote.keymanager.KeyBindingEntry;
+import tkj.android.homecontrol.mythmote.keymanager.KeyBindingManager;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+
+public class MythMoteDbHelper extends SQLiteOpenHelper
+{
+	public static final String DATABASE_NAME = "mythmotedata";
+	public static final int DATABASE_VERSION = 2;
+	public static final String TAG = "MythMoteDB";
+
+	/**
+	 * Field Name declarations
+	 */
+	public static final String KEY_NAME = "name";
+	public static final String KEY_ADDRESS = "address";
+	public static final String KEY_PORT = "port";
+	public static final String KEY_ROWID = "_id";
+	public static final String KEYBINDINGS_ROWID = "_id";
+	public static final String KEYBINDINGS_COMMAND = "myth_command";
+	public static final String KEYBINDINGS_UI_KEY = "ui_key";
+	public static final String KEYBINDINGS_FRIENDLY_NAME = "friendly_name";
+	// to enable a dialog to popup confirming the button action
+	public static final String KEYBINDINGS_REQUIRE_CONFIRMATION = "req_confirm";
+
+	public static final String FRONTEND_TABLE = "frontends";
+	public static final String KEY_BINDINGS_TABLE = "keybindings";
+
+	/**
+	 * Table declarations
+	 */
+	private static final String CREATE_FRONTENDS_TABLE = "create table "
+			+ FRONTEND_TABLE + " (_id integer primary key autoincrement, "
+			+ "name text not null, address text not null, port int);";
+
+	private static final String CREATE_KEY_BINDINGS_TABLE = "create table "
+			+ KEY_BINDINGS_TABLE + " (" + KEYBINDINGS_ROWID
+			+ " integer primary key autoincrement, " + KEYBINDINGS_COMMAND
+			+ " text not null, " + KEYBINDINGS_UI_KEY + " text not null, "
+			+ KEYBINDINGS_FRIENDLY_NAME + " text not null, "
+			+ KEYBINDINGS_REQUIRE_CONFIRMATION + " INTEGER not null );";
+
+	public MythMoteDbHelper(Context context)
+	{
+		super(context, DATABASE_NAME, null, DATABASE_VERSION);
+	}
+
+	@Override
+	public void onCreate(SQLiteDatabase db)
+	{
+		db.execSQL(CREATE_FRONTENDS_TABLE);
+		db.execSQL(CREATE_KEY_BINDINGS_TABLE);
+		createDefaultEntries(db);
+	}
+
+	@Override
+	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
+	{
+		Log.w(TAG, "Upgrading database from version " + oldVersion + " to "
+				+ newVersion + ", which will destroy all old data");
+		if (1 == oldVersion && 2 == newVersion)
+		{
+			// we are just adding key bindings in this case
+			db.execSQL(CREATE_KEY_BINDINGS_TABLE);
+			createDefaultEntries(db);
+		} else
+		{
+			db.execSQL("DROP TABLE IF EXISTS frontends");
+			db.execSQL("DROP TABLE IF EXISTS keybindings");
+			onCreate(db);
+		}
+	}
+
+	private static void createDefaultEntries(SQLiteDatabase db)
+	{
+		for (KeyBindingEntry entry : KeyBindingManager.MythKey
+				.createDefaultList())
+		{
+			ContentValues values = new ContentValues();
+			values.put(KEYBINDINGS_COMMAND, entry.getCommand());
+			values.put(KEYBINDINGS_UI_KEY, entry.getMythKey().name());
+			values.put(KEYBINDINGS_FRIENDLY_NAME, entry.getFriendlyName());
+			values.put(KEYBINDINGS_REQUIRE_CONFIRMATION,
+					entry.requiresConfirmation() ? 1 : 0);
+			Log.d("KBDA", "Adding default entry " + entry.getFriendlyName()
+					+ " to " + entry.getCommand());
+			db.insert(KEY_BINDINGS_TABLE, null, values);
+		}
+	}
+}
Index: src/tkj/android/homecontrol/mythmote/MythMote.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/MythMote.java	(revision 129)
+++ src/tkj/android/homecontrol/mythmote/MythMote.java	(working copy)
@@ -1,36 +1,36 @@
 package tkj.android.homecontrol.mythmote;
 
-
 import tkj.android.homecontrol.mythmote.LocationChangedEventListener;
+import tkj.android.homecontrol.mythmote.db.MythMoteDbHelper;
+import tkj.android.homecontrol.mythmote.db.MythMoteDbManager;
+import tkj.android.homecontrol.mythmote.keymanager.KeyBindingEntry;
+import tkj.android.homecontrol.mythmote.keymanager.KeyBindingManager;
+import tkj.android.homecontrol.mythmote.keymanager.KeyMapBinder;
 import android.app.AlertDialog;
 import android.app.TabActivity;
+import android.content.Context;
 import android.content.Intent;
 import android.content.res.Configuration;
 import android.database.Cursor;
 import android.graphics.Color;
+import android.media.AudioManager;
 import android.os.Bundle;
 import android.widget.Button;
 import android.widget.EditText;
 import android.widget.TabHost;
 import android.widget.TabHost.OnTabChangeListener;
 import android.text.Editable;
-import android.view.HapticFeedbackConstants;
+import android.util.Log;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
 import android.view.View.OnClickListener;
 
+public class MythMote extends TabActivity implements TabHost.TabContentFactory,
+		OnTabChangeListener, LocationChangedEventListener,
+		MythCom.StatusChangedEventListener, KeyMapBinder {
 
-
-public class MythMote extends TabActivity  implements 
-	TabHost.TabContentFactory, 
-	OnTabChangeListener, 
-	LocationChangedEventListener, 
-	MythCom.StatusChangedEventListener
-	{	
-
-
 	public static final int SETTINGS_ID = Menu.FIRST;
 	public static final int RECONNECT_ID = Menu.FIRST + 1;
 	public static final int SELECTLOCATION_ID = Menu.FIRST + 2;
@@ -38,466 +38,331 @@
 	public static final String NAME_MEDIA_TAB = "TabNMediaControl";
 	public static final String NAME_NUMPAD_TAB = "TabNumberPad";
 	
+	private static final String KEY_VOLUME_DOWN = "[";
+	private static final String KEY_VOLUME_UP = "]";
+	
+	private KeyBindingManager keyManager;
+
 	private static TabHost _tabHost;
 	private static MythCom _comm;
 	private static FrontendLocation _location = new FrontendLocation();
 	private static int selected = -1;
-	private static boolean hapticFeedbackEnabled = false;
-	
-	/** Called when the activity is first created.*/
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        
-        //create comm class
-        _comm = new MythCom(this);
-        
-        //set status changed event handler
-        _comm.SetOnStatusChangeHandler(this);
-        
-        //create tab UI
-        _tabHost = getTabHost();
-        
-        //create tabs
-    	createTabs();
-        
-        //setup on tab change event
-        _tabHost.setOnTabChangedListener(this);
-        
-        //set navigation tab and setup events
-        _tabHost.setCurrentTab(0);
-        
-        //setup navifation panel button events
-        setupNavigationPanelButtonEvents();
-    }
-    
-    /** Called when the activity is resumed **/
-    @Override
-    public void onResume(){
-    	super.onResume();
 
-    	//connect to saved location
-        connectToSelectedLocation();
-    }
-    
+	/** Called when the activity is first created. */
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+
+		// create comm class
+		_comm = new MythCom(this);
+
+		// set status changed event handler
+		_comm.SetOnStatusChangeHandler(this);
+		
+		keyManager = new KeyBindingManager(this, this, _comm);
+		keyManager.loadKeys();
+
+		// create tab UI
+		_tabHost = getTabHost();
+		_tabHost.addTab(_tabHost
+				.newTabSpec(NAME_NAV_TAB)
+				.setIndicator(this.getString(R.string.navigation_str),
+						this.getResources().getDrawable(R.drawable.starsmall))
+				.setContent(this));
+		_tabHost.addTab(_tabHost
+				.newTabSpec(NAME_MEDIA_TAB)
+				.setIndicator(this.getString(R.string.media_str),
+						this.getResources().getDrawable(R.drawable.media))
+				.setContent(this));
+		_tabHost.addTab(_tabHost
+				.newTabSpec(NAME_NUMPAD_TAB)
+				.setIndicator(this.getString(R.string.numpad_str),
+						this.getResources().getDrawable(R.drawable.numberpad))
+				.setContent(this));
+
+		// setup on tab change event
+		_tabHost.setOnTabChangedListener(this);
+
+		// register ourselves as a "media"
+		//this.setVolumeControlStream(AudioManager.STREAM_MUSIC);
+
+		// set navigation tab and setup events
+		_tabHost.setCurrentTab(0);
+		keyManager.loadKeys();
+	}
+
+	/** Called when the activity is resumed **/
+	@Override
+	public void onResume() {
+		super.onResume();
+
+		// connect to saved location
+		connectToSelectedLocation();
+	}
+
 	/** Called when the activity is paused **/
-    @Override
-    public void onPause(){
-    	super.onPause();
-    	
-    	//disconnect from frontend
-    	_comm.Disconnect();
+	@Override
+	public void onPause() {
+		super.onPause();
 
-    }
-    
-    /** Called when device configuration changes occur. Configuration 
-     * changes that cause this function to be called must be 
-     * registered in AndroidManifest.xml **/
-    public void onConfigurationChanged(Configuration config)
-    {
-    	super.onConfigurationChanged(config);
-    	
-    	//get current tab index
-    	int cTab = _tabHost.getCurrentTab();
-    	
-    	//set current tab to 0. Clear seems to fail when set to anything else
-    	_tabHost.setCurrentTab(0);
-    	
-    	//clear all tabs
-    	_tabHost.clearAllTabs();
-    	
-    	//create tabs
-    	createTabs();
-        
-        //set current tab back
-        _tabHost.setCurrentTab(cTab);
-    }
-    
-    /**
-     * Overridden to allow the hardware volume controls to influence the Myth front end
-     * volume control
-     */
-    //@Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-            switch (keyCode) {
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-                    _comm.SendKey(MythCom.VOLUME_DOWN);
-                    return true;
-            case KeyEvent.KEYCODE_VOLUME_UP:
-                    _comm.SendKey(MythCom.VOLUME_UP);
-                    return true;
-            default:
-                    return super.onKeyDown(keyCode, event);
+		// disconnect from frontend
+		_comm.Disconnect();
 
-            }
+	}
 
-    }
-    
-    /** Called to create the options menu once.  **/
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        boolean result = super.onCreateOptionsMenu(menu);
-        
-        //create settings  menu item
-        menu.add(0, SETTINGS_ID, 0, R.string.settings_menu_str).setIcon(R.drawable.settings);
-        
-        //create reconnect menu item
-        menu.add(0, RECONNECT_ID, 0, R.string.reconnect_str).setIcon(R.drawable.menu_refresh);
-        
-        //create select location menu item
-        menu.add(0, SELECTLOCATION_ID, 0, R.string.selected_location_str).setIcon(R.drawable.home);
-        
-        //return results
-        return result;
-    }
-    
-    /** Called when a menu item is selected **/
-   @Override
-    public boolean onOptionsItemSelected(MenuItem item){
-	   try
-	   {
-		   //Check which menu item was selected
-		   switch(item.getItemId())
-		   {
-		   		case SETTINGS_ID:
-		   			//Create mythmote preferences intent and start the activity
-		   			Intent intent = new Intent(this, tkj.android.homecontrol.mythmote.MythMotePreferences.class);
-				   	this.startActivity(intent);
-				   	break;
+	/**
+	 * Called when device configuration changes occur. Configuration changes
+	 * that cause this function to be called must be registered in
+	 * AndroidManifest.xml
+	 **/
+	public void onConfigurationChanged(Configuration config) {
+		super.onConfigurationChanged(config);
+	}
 
-		   		case RECONNECT_ID:
-		   			//connect to selected location
-		   			this.connectToSelectedLocation();
-		   			break;
-		   			
-		   		case SELECTLOCATION_ID:
-		   			//Displays the list of configured frontend locations.
-					//Fires the locationChanged event when the user selects a location
-					//even if the user selects the same location already selected.
-					MythMotePreferences.SelectLocation(this, this);
-		   			break;
-		   };
-	   }
-	   catch(android.content.ActivityNotFoundException ex)
-	   {
-		   //Show error when actibity is not found
-		   AlertDialog.Builder diag = new AlertDialog.Builder(this);
-		   diag.setMessage(ex.getMessage());
-		   diag.setTitle("Error");
-		   diag.setNeutralButton("OK", null);
-		   diag.show();
-	   }
-    	return false;
-    }
-   
-    /** Called when the selected tab page is changed **/
+	/** Called to create the options menu once. **/
+	@Override
+	public boolean onCreateOptionsMenu(Menu menu) {
+		boolean result = super.onCreateOptionsMenu(menu);
+
+		// create settings menu item
+		menu.add(0, SETTINGS_ID, 0, R.string.settings_menu_str).setIcon(
+				R.drawable.settings);
+
+		// create reconnect menu item
+		menu.add(0, RECONNECT_ID, 0, R.string.reconnect_str).setIcon(
+				R.drawable.menu_refresh);
+
+		// create select location menu item
+		menu.add(0, SELECTLOCATION_ID, 0, R.string.selected_location_str)
+				.setIcon(R.drawable.home);
+
+		// return results
+		return result;
+	}
+
+	/** Called when a menu item is selected **/
+	@Override
+	public boolean onOptionsItemSelected(MenuItem item) {
+		try {
+			// Check which menu item was selected
+			switch (item.getItemId()) {
+			case SETTINGS_ID:
+				// Create mythmote preferences intent and start the activity
+				Intent intent = new Intent(
+						this,
+						tkj.android.homecontrol.mythmote.MythMotePreferences.class);
+				this.startActivity(intent);
+				break;
+
+			case RECONNECT_ID:
+				// connect to selected location
+				this.connectToSelectedLocation();
+				break;
+
+			case SELECTLOCATION_ID:
+				// Displays the list of configured frontend locations.
+				// Fires the locationChanged event when the user selects a
+				// location
+				// even if the user selects the same location already selected.
+				MythMotePreferences.SelectLocation(this, this);
+				break;
+			}
+			;
+		} catch (android.content.ActivityNotFoundException ex) {
+			// Show error when actibity is not found
+			AlertDialog.Builder diag = new AlertDialog.Builder(this);
+			diag.setMessage(ex.getMessage());
+			diag.setTitle("Error");
+			diag.setNeutralButton("OK", null);
+			diag.show();
+		}
+		return false;
+	}
+
+	/** Called when the selected tab page is changed **/
 	public void onTabChanged(String arg0) {
-		
-		//get tab tag
+
+		// get tab tag
 		String tabTag = _tabHost.getCurrentTabTag();
-		
-		//check for which tab has been selected
-		if(tabTag.equals(NAME_NAV_TAB))
-		{
-			//setup navigation tab button events
-			setupNavigationPanelButtonEvents();
+
+		// check for which tab has been selected
+		if (tabTag.equals(NAME_NAV_TAB)) {
+			// setup navigation tab button events
+//			setupNavigationPanelButtonEvents();
+		} else if (tabTag.equals(NAME_MEDIA_TAB)) {
+			// setup media tab button events
+//			setupMediaPanelButtonEvents();
+		} else if (tabTag.equals(NAME_NUMPAD_TAB)) {
+			// setup number pad button events
+//			setupNumberPadButtonEvents();
 		}
-		else if(tabTag.equals(NAME_MEDIA_TAB))
-		{
-			//setup media tab button events
-			setupMediaPanelButtonEvents();
-		}
-		else if(tabTag.equals(NAME_NUMPAD_TAB))
-		{
-			//setup number pad button events
-			setupNumberPadButtonEvents();
-		}
 	}
-	
+
 	/**
-	 * Called to create and add tabs to the tabhost
+	 * Called when a tab is selected. Returns the layout for the selected tab.
+	 * Default is navigation tab
 	 */
-	private void createTabs()
-	{
-		//recreate tabs
-    	_tabHost.addTab(_tabHost.newTabSpec(NAME_NAV_TAB).setIndicator(
-        		this.getString(R.string.navigation_str),
-        		this.getResources().getDrawable(R.drawable.starsmall)).setContent(this));
-        _tabHost.addTab(_tabHost.newTabSpec(NAME_MEDIA_TAB).setIndicator(
-        		this.getString(R.string.media_str),
-        		this.getResources().getDrawable(R.drawable.media)).setContent(this));
-        _tabHost.addTab(_tabHost.newTabSpec(NAME_NUMPAD_TAB).setIndicator(
-        		this.getString(R.string.numpad_str),
-        		this.getResources().getDrawable(R.drawable.numberpad)).setContent(this));
-	}
-	
-	private void loadSharedPreferences()
-	{
-		//get selected frontend id
-		selected = this.getSharedPreferences(MythMotePreferences.MYTHMOTE_SHARED_PREFERENCES_ID, MODE_PRIVATE)
-        	.getInt(MythMotePreferences.PREF_SELECTED_LOCATION, -1);
-		
-		hapticFeedbackEnabled = this.getSharedPreferences(MythMotePreferences.MYTHMOTE_SHARED_PREFERENCES_ID, MODE_PRIVATE)
-			.getBoolean(MythMotePreferences.PREF_HAPTIC_FEEDBACK_ENABLED, false);
-	}
-   
-    /** Called when a tab is selected. Returns the layout for the selected tab. 
-    * Default is navigation tab */
 	public View createTabContent(String tag) {
-		
-		//check which tab content to return
-		if(tag == NAME_NAV_TAB)
-		{
-			//get navigation tab view
-			return this.getLayoutInflater().inflate(R.layout.navigation, this.getTabHost().getTabContentView(), false);
+
+		// check which tab content to return
+		if (tag == NAME_NAV_TAB) {
+			// get navigation tab view
+			return this.getLayoutInflater().inflate(R.layout.navigation,
+					this.getTabHost().getTabContentView(), false);
+		} else if (tag == NAME_MEDIA_TAB) {
+			// return media tab view
+			return this.getLayoutInflater().inflate(R.layout.mediacontrol,
+					this.getTabHost().getTabContentView(), false);
+		} else if (tag == NAME_NUMPAD_TAB) {
+			// return number pad view
+			return this.getLayoutInflater().inflate(R.layout.numberpad,
+					this.getTabHost().getTabContentView(), false);
+		} else {
+			// default to navigation tab view
+			return this.getLayoutInflater().inflate(R.layout.navigation,
+					this.getTabHost().getTabContentView(), false);
 		}
-		else if(tag == NAME_MEDIA_TAB)
-		{
-			//return media tab view
-			return this.getLayoutInflater().inflate(R.layout.mediacontrol, this.getTabHost().getTabContentView(), false);
-		}
-		else if(tag == NAME_NUMPAD_TAB)
-		{
-			//return number pad view
-			return this.getLayoutInflater().inflate(R.layout.numberpad, this.getTabHost().getTabContentView(), false);
-		}
-		else
-		{
-			//default to navigation tab view
-			return this.getLayoutInflater().inflate(R.layout.navigation, this.getTabHost().getTabContentView(), false);
-		}
 	}
 
 	/** Called when the frontend location is changed */
 	public void LocationChanged() {
-		
-		//connect to selected location
+
+		// connect to selected location
 		this.connectToSelectedLocation();
 	}
-   
+
 	/** Called when MythCom status changes **/
-    public void StatusChanged(String StatusMsg, int statusCode) {
-		//set titleJUMPPOINT_guidegrid
+	public void StatusChanged(String StatusMsg, int statusCode) {
+		// set titleJUMPPOINT_guidegrid
 		setTitle(StatusMsg);
-		
-		//change color based on status code
-		if(statusCode == MythCom.STATUS_ERROR)
-		{
+
+		// change color based on status code
+		if (statusCode == MythCom.STATUS_ERROR) {
 			setTitleColor(Color.RED);
-		}
-		else if(statusCode == MythCom.STATUS_DISCONNECTED)
-		{
+		} else if (statusCode == MythCom.STATUS_DISCONNECTED) {
 			setTitleColor(Color.RED);
-		}
-		else if(statusCode == MythCom.STATUS_CONNECTED)
-		{
+		} else if (statusCode == MythCom.STATUS_CONNECTED) {
 			setTitleColor(Color.GREEN);
-		}
-		else if(statusCode == MythCom.STATUS_CONNECTING)
-		{
+		} else if (statusCode == MythCom.STATUS_CONNECTING) {
 			setTitleColor(Color.YELLOW);
 		}
 	}
-	
-    /** Reads the selected frontend from preferences and attempts to connect with MythCom.Connect() **/
+
+	/**
+	 * Reads the selected frontend from preferences and attempts to connect with
+	 * MythCom.Connect()
+	 **/
 	private void connectToSelectedLocation() {
-		
-		//load shared preferences
-		this.loadSharedPreferences();
 
-		//create location database adapter
-        LocationDbAdapter dbAdatper = new LocationDbAdapter(this);
-        
-        //open connect
-        dbAdatper.open();
-        
-        //get the selected location information by it's ID
-        Cursor cursor = dbAdatper.fetchFrontendLocation(selected);
-        
-        //make sure returned cursor is valid
-        if(cursor != null && cursor.getCount() > 0)
-        {
-        	//set selected location from Cursor
-        	_location.ID = cursor.getInt(cursor.getColumnIndex(LocationDbAdapter.KEY_ROWID));
-        	_location.Name = cursor.getString(cursor.getColumnIndex(LocationDbAdapter.KEY_NAME));
-        	_location.Address = cursor.getString(cursor.getColumnIndex(LocationDbAdapter.KEY_ADDRESS));
-        	_location.Port = cursor.getInt(cursor.getColumnIndex(LocationDbAdapter.KEY_PORT));
-        }
-        
-        //close cursor and db adapter
-        cursor.close();
-        dbAdatper.close();
-    	
-    	//connect to location if it is not null
-    	if(_location != null)
-    		_comm.Connect(_location);
+		// get selected frontend id
+		selected = this.getSharedPreferences(
+				MythMotePreferences.MYTHMOTE_SHARED_PREFERENCES_ID,
+				MODE_PRIVATE).getInt(
+				MythMotePreferences.PREF_SELECTED_LOCATION, -1);
+
+		// create location database adapter
+		MythMoteDbManager dbManager = new MythMoteDbManager(this);
+
+		// open connect
+		dbManager.open();
+
+		// get the selected location information by it's ID
+		Cursor cursor = dbManager.fetchFrontendLocation(selected);
+
+		// make sure returned cursor is valid
+		if (cursor != null && cursor.getCount() > 0) {
+			// set selected location from Cursor
+			_location.ID = cursor.getInt(cursor
+					.getColumnIndex(MythMoteDbHelper.KEY_ROWID));
+			_location.Name = cursor.getString(cursor
+					.getColumnIndex(MythMoteDbHelper.KEY_NAME));
+			_location.Address = cursor.getString(cursor
+					.getColumnIndex(MythMoteDbHelper.KEY_ADDRESS));
+			_location.Port = cursor.getInt(cursor
+					.getColumnIndex(MythMoteDbHelper.KEY_PORT));
+		}
+
+		// close cursor and db adapter
+		cursor.close();
+		dbManager.close();
+
+		// connect to location if it is not null
+		if (_location != null)
+			_comm.Connect(_location);
 	}
-	
-	/** Sets up the navigation tab's button events **/
-    private void setupNavigationPanelButtonEvents()
-    {
-    	// jump buttons.
-    	// TODO: Make these user definable in a later release
-    	this.setupJumpButtonEvent(R.id.ButtonJump1, MythCom.JUMPPOINT_mainmenu);
-    	this.setupJumpButtonEvent(R.id.ButtonJump2, MythCom.JUMPPOINT_livetv);
-    	this.setupJumpButtonEvent(R.id.ButtonJump3, MythCom.JUMPPOINT_playbackrecordings);
-    	this.setupJumpButtonEvent(R.id.ButtonJump4, MythCom.JUMPPOINT_playmusic);
-    	this.setupJumpButtonEvent(R.id.ButtonJump5, MythCom.JUMPPOINT_videogallery);
-    	this.setupJumpButtonEvent(R.id.ButtonJump6, MythCom.JUMPPOINT_statusbox);
-    	
-	    //navigation buttons
-    	this.setupKeyButtonEvent(R.id.ButtonInfo, "i");
-    	this.setupKeyButtonEvent(R.id.ButtonGuide, "s");
-    	this.setupKeyButtonEvent(R.id.ButtonEsc, MythCom.KEY_esc);
-    	this.setupKeyButtonEvent(R.id.ButtonMenu, "m");
-	    this.setupKeyButtonEvent(R.id.ButtonUp, MythCom.KEY_up);
-	    this.setupKeyButtonEvent(R.id.ButtonDown, MythCom.KEY_down);
-	    this.setupKeyButtonEvent(R.id.ButtonLeft, MythCom.KEY_left);
-	    this.setupKeyButtonEvent(R.id.ButtonRight, MythCom.KEY_right);
-	    this.setupKeyButtonEvent(R.id.ButtonSelect, MythCom.KEY_enter);
-	    
-    }
-    
-    /** Sets up the Media playback tab's buttons **/
-    private void setupMediaPanelButtonEvents()
-    {
-    	// media playback
-    	this.setupKeyButtonEvent(R.id.ButtonRecord, "r");
-    	this.setupPlaybackCmdButtonEvent(R.id.ButtonStop, MythCom.PLAY_STOP);
-    	this.setupPlaybackCmdButtonEvent(R.id.ButtonPlay, MythCom.PLAY_PLAY);
-    	this.setupPlaybackCmdButtonEvent(R.id.ButtonRew, MythCom.PLAY_SEEK_BW);
-    	this.setupPlaybackCmdButtonEvent(R.id.ButtonFF, MythCom.PLAY_SEEK_FW);
-    	this.setupKeyButtonEvent(R.id.ButtonPause, "p");
-    	this.setupKeyButtonEvent(R.id.ButtonSkipBack, "home");
-    	this.setupKeyButtonEvent(R.id.ButtonSkipForward, "end");
-    	
-    	//volume
-    	this.setupKeyButtonEvent(R.id.ButtonVolUp, MythCom.VOLUME_UP);
-    	this.setupKeyButtonEvent(R.id.ButtonVolDown, MythCom.VOLUME_DOWN);
-    	this.setupKeyButtonEvent(R.id.ButtonMute, MythCom.VOLUME_MUTE);
-    	
-    	//ch
-    	this.setupPlaybackCmdButtonEvent(R.id.ButtonChUp, MythCom.PLAY_CH_UP);
-    	this.setupPlaybackCmdButtonEvent(R.id.ButtonChDown, MythCom.PLAY_CH_DW);
-	    this.setupKeyButtonEvent(R.id.ButtonChReturn, MythCom.CH_RETURN);
-    }
-    
-    /** Sets up the number pad tab's buttons **/
-    private void setupNumberPadButtonEvents()
-    {
-    	//numbers
-    	this.setupKeyButtonEvent(R.id.Button0, "0");
-	    this.setupKeyButtonEvent(R.id.Button1, "1");
-	    this.setupKeyButtonEvent(R.id.Button2, "2");
-	    this.setupKeyButtonEvent(R.id.Button3, "3");
-	    this.setupKeyButtonEvent(R.id.Button4, "4");
-	    this.setupKeyButtonEvent(R.id.Button5, "5");
-	    this.setupKeyButtonEvent(R.id.Button6, "6");
-	    this.setupKeyButtonEvent(R.id.Button7, "7");
-	    this.setupKeyButtonEvent(R.id.Button8, "8");
-	    this.setupKeyButtonEvent(R.id.Button9, "9");
-	    
-	    
-	    //control
-	    this.setupKeyButtonEvent(R.id.ButtonBackspace, MythCom.KEY_backspace);
-	    this.setupKeyButtonEvent(R.id.ButtonEnter, MythCom.KEY_enter);
-	    
-	    //send keyboard input
-	    final Button buttonJump = (Button) this.findViewById(R.id.ButtonSend);
-	    final EditText textBox = (EditText) this.findViewById(R.id.EditTextKeyboardInput);
-	    if(buttonJump != null && textBox != null)
-	    {
-		    buttonJump.setOnClickListener(new OnClickListener() {
-		        public void onClick(View v) {
-		            
-		        	//get send keyboard text
-		        	Editable text = textBox.getText();
-		        	int count = text.length();
-		        	
-		        	//for each character
-		        	for(int i=0; i<count; i++)
-		        	{
-		        		//get char
-		        		char c = text.charAt(i);
-		        		
-		        		//check if it's whitespace
-		        		if(Character.isWhitespace(c))
-		        		{
-		        			if(c == '\t')//tab
-		        			{
-		        				_comm.SendKey("tab");
-		        			}
-		        			else if(c == ' ')//space
-		        			{
-		        				_comm.SendKey("space");
-		        			}
-		        			else if(c == '\r')//enter/return
-		        			{
-		        				_comm.SendKey("enter");
-		        			}
-		        		}
-		        		else//not white space. Just send as is
-		        		{
-		        			_comm.SendKey(c);
-		        		}
-		        	}
-		        }
-		    });
-	    }
-	    
-    }
-    
-    /** Sets up a mythcom jump button click event  **/
-    private final void setupJumpButtonEvent(int buttonViewId, final String jumpPoint)
-    {
-    	final Button button = (Button) this.findViewById(buttonViewId);
-	    button.setOnClickListener(new OnClickListener() {
-	        public void onClick(View v) {
-	            // Perform action on clicks
-	            _comm.SendJumpCommand(jumpPoint);
-	            
-	            if(hapticFeedbackEnabled)
-	            	button.performHapticFeedback(1, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
-	        }
-	    });
-    }
-    
-    /** Sets up a mythcom keyboard button click event **/
-    private final void setupKeyButtonEvent(int buttonViewId, final String sendKey)
-    {
-    	final Button button = (Button) this.findViewById(buttonViewId);
-	    button.setOnClickListener(new OnClickListener() {
-	        public void onClick(View v) {
-	            // Perform action on clicks
-	            _comm.SendKey(sendKey);
-	            
-	            if(hapticFeedbackEnabled)
-	            	button.performHapticFeedback(1, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
-	        }
-	    });
-    }
-    
-    /** Sets up a mythcom playback command button click event **/
-    private final void setupPlaybackCmdButtonEvent(int buttonViewId, final String sendCmd)
-    {
-    	final Button button = (Button) this.findViewById(buttonViewId);
-	    button.setOnClickListener(new OnClickListener() {
-	        public void onClick(View v) {
-	            // Perform action on clicks
-	            _comm.SendPlaybackCmd(sendCmd);
-	            
-	            if(hapticFeedbackEnabled)
-	            	button.performHapticFeedback(1, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
-	        }
-	    });
-    }
 
+	/** Sets up a mythcom jump button click event **/
+	private final void setupJumpButtonEvent(int buttonViewId,
+			final String jumpPoint) {
+		final Button buttonJump = (Button) this.findViewById(buttonViewId);
 
+		buttonJump.setOnClickListener(new OnClickListener() {
+			public void onClick(View v) {
+				// Perform action on clicks
+				_comm.SendJumpCommand(jumpPoint);
+			}
+		});
+	}
 
-}
+	/** Sets up a mythcom keyboard button click event **/
+	private final void setupKeyButtonEvent(int buttonViewId,
+			final String sendKey) {
+		final Button button = (Button) this.findViewById(buttonViewId);
+		button.setOnClickListener(new OnClickListener() {
+			public void onClick(View v) {
+				// Perform action on clicks
+				_comm.SendKey(sendKey);
+			}
+		});
+	}
 
+	/** Sets up a mythcom playback command button click event **/
+	private final void setupPlaybackCmdButtonEvent(int buttonViewId,
+			final String sendCmd) {
+		final Button button = (Button) this.findViewById(buttonViewId);
+		button.setOnClickListener(new OnClickListener() {
+			public void onClick(View v) {
+				// Perform action on clicks
+				_comm.SendPlaybackCmd(sendCmd);
+			}
+		});
+	}
 
+	/**
+	 * Overridden to allow the hardware volume controls to influence the Myth front end 
+	 * volume control
+	 */
+	@Override
+	public boolean onKeyDown(int keyCode, KeyEvent event) {
+		switch (keyCode) {
+		case KeyEvent.KEYCODE_VOLUME_DOWN:
+			_comm.SendKey(KEY_VOLUME_DOWN);
+			return true;
+		case KeyEvent.KEYCODE_VOLUME_UP:
+			_comm.SendKey(KEY_VOLUME_UP);
+			return true;
+		default:
+			return super.onKeyDown(keyCode, event);
 
+		}
 
+	}
 
+	/**
+	 * Enable the long click and normal click actions where
+	 * a long click will configure the button, and a normal tap
+	 * will perform the command
+	 * 
+	 * This is the callback from the {@link KeyBindingManager}
+	 */
+	public View bind(KeyBindingEntry entry) {
+		View v = this.findViewById(entry.getMythKey().getButtonId());
+		if ( null == v )
+			return null;
+		v.setLongClickable(true);
+		v.setOnLongClickListener(keyManager);
+		v.setOnClickListener(keyManager);
+		return v;
+	}
 
+}
Index: src/tkj/android/homecontrol/mythmote/FrontendLocation.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/FrontendLocation.java	(revision 129)
+++ src/tkj/android/homecontrol/mythmote/FrontendLocation.java	(working copy)
@@ -3,23 +3,21 @@
 /*
  * Contains all information for a mythtv frontend.
  * */
-public class FrontendLocation {
+public class FrontendLocation
+{
 
 	public static String STR_ID = "ID";
 	public static String STR_NAME = "NAME";
 	public static String STR_ADDRESS = "ADDRESS";
 	public static String STR_PORT = "PORT";
-	
-	
+
 	public int ID = -1;
 	public String Name = "";
 	public String Address = "";
 	public int Port = 6456;
-	
-	
-	
+
 	public FrontendLocation()
 	{
-		
+
 	}
 }
Index: src/tkj/android/homecontrol/mythmote/MythMotePreferences.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/MythMotePreferences.java	(revision 129)
+++ src/tkj/android/homecontrol/mythmote/MythMotePreferences.java	(working copy)
@@ -1,7 +1,7 @@
-
 package tkj.android.homecontrol.mythmote;
 
-
+import tkj.android.homecontrol.mythmote.db.MythMoteDbHelper;
+import tkj.android.homecontrol.mythmote.db.MythMoteDbManager;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.Context;
@@ -19,7 +19,8 @@
 import android.view.Menu;
 import android.view.MenuItem;
 
-public class MythMotePreferences extends PreferenceActivity{
+public class MythMotePreferences extends PreferenceActivity
+{
 
 	public static final int NEW_LOCATION_ID = Menu.FIRST;
 	public static final int DELETE_LOCATION_ID = Menu.FIRST + 1;
@@ -27,243 +28,252 @@
 	public static final String PREF_SELECTED_LOCATION = "selected-frontend";
 	public static final String PREF_HAPTIC_FEEDBACK_ENABLED = "haptic-feedback-enabled";
 	public static final int REQUEST_LOCATIONEDITOR = 0;
-	
+
 	private static int _idIndex;
 	private static int _addressIndex;
 	private static int _nameIndex;
 	private static int _portIndex;
-    
+
 	@Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        
-//        //create base preference screen
-//        PreferenceScreen prefScreen = this.getPreferenceManager().createPreferenceScreen(this);
-//       
-//        //configure all preferences
-//        setupPreferences(prefScreen);
-//        
-//        //set preference screen
-//		this.setPreferenceScreen(prefScreen);
-        this.getPreferenceManager().setSharedPreferencesName(MYTHMOTE_SHARED_PREFERENCES_ID);
-    }
-	
+	protected void onCreate(Bundle savedInstanceState)
+	{
+		super.onCreate(savedInstanceState);
+
+		// //create base preference screen
+		// PreferenceScreen prefScreen =
+		// this.getPreferenceManager().createPreferenceScreen(this);
+		//
+		// //configure all preferences
+		// setupPreferences(prefScreen);
+		//
+		// //set preference screen
+		// this.setPreferenceScreen(prefScreen);
+		this.getPreferenceManager().setSharedPreferencesName(
+				MYTHMOTE_SHARED_PREFERENCES_ID);
+	}
+
 	@Override
-    public void onResume()
-    {
+	public void onResume()
+	{
 		super.onResume();
-        //configure all preferences
-        setupPreferences(this);
-    }
-	
+		// configure all preferences
+		setupPreferences(this);
+	}
+
 	@Override
-	public boolean onCreateOptionsMenu(Menu menu) {
+	public boolean onCreateOptionsMenu(Menu menu)
+	{
 		boolean result = super.onCreateOptionsMenu(menu);
-        menu.add(0, NEW_LOCATION_ID, 0, R.string.add_location_str).setIcon(R.drawable.menu_add);
-        menu.add(0, DELETE_LOCATION_ID, 0, R.string.delete_location_str).setIcon(R.drawable.menu_close_clear_cancel);
-        return result;
+		menu.add(0, NEW_LOCATION_ID, 0, R.string.add_location_str).setIcon(
+				R.drawable.menu_add);
+		menu.add(0, DELETE_LOCATION_ID, 0, R.string.delete_location_str)
+				.setIcon(R.drawable.menu_close_clear_cancel);
+		return result;
 	}
-	
+
 	@Override
-    public boolean onOptionsItemSelected(MenuItem item)
-    {
-    	final PreferenceActivity context = this;
-    	
-		if(item.getItemId() == NEW_LOCATION_ID)
+	public boolean onOptionsItemSelected(MenuItem item)
+	{
+		final PreferenceActivity context = this;
+
+		if (item.getItemId() == NEW_LOCATION_ID)
 		{
 			showLocationEditDialog(context, null);
-		}
-		else if(item.getItemId() == DELETE_LOCATION_ID)
+		} else if (item.getItemId() == DELETE_LOCATION_ID)
 		{
 			showDeleteLocationList(context);
 		}
 		return true;
-    }
+	}
 
 	private static void setupPreferences(PreferenceActivity context)
 	{
-		//create Categories
-		PreferenceScreen prefScreen = context.getPreferenceManager().createPreferenceScreen(context);
+		// create Categories
+		PreferenceScreen prefScreen = context.getPreferenceManager()
+				.createPreferenceScreen(context);
 		prefScreen.removeAll();
-		
-        PreferenceCategory selectedCat = new PreferenceCategory(context);
-        selectedCat.setTitle(R.string.selected_location_str);
-        PreferenceCategory locationListCat = new PreferenceCategory(context);
-        locationListCat.setTitle(R.string.location_list_str);
-        PreferenceCategory generalCat = new PreferenceCategory(context);
-        generalCat.setTitle(R.string.general_preferences_str);
 
-        //add categories to preference screen
-        prefScreen.addPreference(selectedCat);
-        prefScreen.addPreference(locationListCat);
-        prefScreen.addPreference(generalCat);
-        
-        //Create add and delete location preferences and add to location list
-        locationListCat.addPreference(createAddLocationPreference(
-        		context, 
-        		context.getString(R.string.add_location_str),
-        		context.getString(R.string.add_location_description_str)));
-        locationListCat.addPreference(createDeleteLocationPreference(
-        		context, 
-        		context.getString(R.string.delete_location_str),
-        		context.getString(R.string.delete_location_description_str)));
-        
-        //read haptic feedback shared preference
-        generalCat.addPreference(createCheckBox(
-        		context, 
-        		PREF_HAPTIC_FEEDBACK_ENABLED, 
-        		R.string.haptic_feedback_enabled_str,
-        		R.string.haptic_feedback_enabled_description_str,
-        		false));
-        
-        //open DB
-        LocationDbAdapter _dbAdapter = new LocationDbAdapter(context);
-        _dbAdapter.open();
-        
-        //get list of locations
-        Cursor cursor = _dbAdapter.fetchAllFrontendLocations();
-        
-        //get column indexes 
-        _idIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_ROWID);
-        _addressIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_ADDRESS);
-        _nameIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_NAME);
-        _portIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_PORT);
-        
-        //determine if we have locations saved
-        int count = cursor.getCount();
-        if(count > 0 && cursor.moveToFirst())
-        {
-            //get selected frontend id
-            int selected = context.getSharedPreferences(MYTHMOTE_SHARED_PREFERENCES_ID, MODE_PRIVATE)
-            	.getInt(MythMotePreferences.PREF_SELECTED_LOCATION, -1);
-            
-            //if selected failed
-            if(selected == -1)
-            {
-            	//set to first in list
-            	selected = cursor.getInt(_idIndex);
-            	//save (defaulted) selected location
-    			SaveSelectedLocationId(context, selected);
-            }
-        	
-        	//put each location in the preference list
-        	for(int i=0; i<count; i++)
-        	{
-        		locationListCat.addPreference(
-        				MythMotePreferences.createLocationPreference(
-        						context,
-        						cursor.getString(_idIndex),
-        						cursor.getString(_nameIndex), 
-        						cursor.getString(_addressIndex)));
-        		
-        		if(cursor.getInt(_idIndex) == selected)
-        		{
-        			//create preference for selected location
-        			selectedCat.addPreference(
-                			MythMotePreferences.createSelectedLocationPreference(
-                					context, context.getString(R.string.selected_location_str), cursor.getString(_nameIndex)));
-        		}
+		PreferenceCategory selectedCat = new PreferenceCategory(context);
+		selectedCat.setTitle(R.string.selected_location_str);
+		PreferenceCategory locationListCat = new PreferenceCategory(context);
+		locationListCat.setTitle(R.string.location_list_str);
+		PreferenceCategory generalCat = new PreferenceCategory(context);
+		generalCat.setTitle(R.string.general_preferences_str);
 
-        		cursor.moveToNext();
-        	}
-        	
-        	//the saved selected location was not found just pick the first one
-        	if(selectedCat.getPreferenceCount() <= 0)
-        	{
-        		cursor.moveToFirst();
-        		selectedCat.addPreference(
-            			MythMotePreferences.createSelectedLocationPreference(
-            					context, context.getString(R.string.selected_location_str), cursor.getString(_nameIndex)));
+		// add categories to preference screen
+		prefScreen.addPreference(selectedCat);
+		prefScreen.addPreference(locationListCat);
+		prefScreen.addPreference(generalCat);
 
-        		//save location ID so that it is for real
-        		SaveSelectedLocationId(context, cursor.getInt(_idIndex));
-        	}
-        }
-        else
-        {
-        	selectedCat.addPreference(
-        			MythMotePreferences.createSelectedLocationPreference(
-        					context, 
-        					context.getString(R.string.selected_location_str),
-        					context.getString(R.string.no_frontend_locations_defined_str)));
-        }
-        
-        cursor.close();
-        _dbAdapter.close();
-        
-        
-        //set preference screen
+		// Create add and delete location preferences and add to location list
+		locationListCat.addPreference(createAddLocationPreference(context,
+				context.getString(R.string.add_location_str),
+				context.getString(R.string.add_location_description_str)));
+		locationListCat.addPreference(createDeleteLocationPreference(context,
+				context.getString(R.string.delete_location_str),
+				context.getString(R.string.delete_location_description_str)));
+
+		// read haptic feedback shared preference
+		generalCat.addPreference(createCheckBox(context,
+				PREF_HAPTIC_FEEDBACK_ENABLED,
+				R.string.haptic_feedback_enabled_str,
+				R.string.haptic_feedback_enabled_description_str, false));
+
+		// open DB
+		MythMoteDbManager _dbAdapter = new MythMoteDbManager(context);
+		_dbAdapter.open();
+
+		// get list of locations
+		Cursor cursor = _dbAdapter.fetchAllFrontendLocations();
+
+		// get column indexes
+		_idIndex = cursor.getColumnIndex(MythMoteDbHelper.KEY_ROWID);
+		_addressIndex = cursor.getColumnIndex(MythMoteDbHelper.KEY_ADDRESS);
+		_nameIndex = cursor.getColumnIndex(MythMoteDbHelper.KEY_NAME);
+		_portIndex = cursor.getColumnIndex(MythMoteDbHelper.KEY_PORT);
+
+		// determine if we have locations saved
+		int count = cursor.getCount();
+		if (count > 0 && cursor.moveToFirst())
+		{
+			// get selected frontend id
+			int selected = context.getSharedPreferences(
+					MYTHMOTE_SHARED_PREFERENCES_ID, MODE_PRIVATE).getInt(
+					MythMotePreferences.PREF_SELECTED_LOCATION, -1);
+
+			// if selected failed
+			if (selected == -1)
+			{
+				// set to first in list
+				selected = cursor.getInt(_idIndex);
+				// save (defaulted) selected location
+				SaveSelectedLocationId(context, selected);
+			}
+
+			// put each location in the preference list
+			for (int i = 0; i < count; i++)
+			{
+				locationListCat.addPreference(MythMotePreferences
+						.createLocationPreference(context,
+								cursor.getString(_idIndex),
+								cursor.getString(_nameIndex),
+								cursor.getString(_addressIndex)));
+
+				if (cursor.getInt(_idIndex) == selected)
+				{
+					// create preference for selected location
+					selectedCat.addPreference(MythMotePreferences
+							.createSelectedLocationPreference(context, context
+									.getString(R.string.selected_location_str),
+									cursor.getString(_nameIndex)));
+				}
+
+				cursor.moveToNext();
+			}
+
+			// the saved selected location was not found just pick the first one
+			if (selectedCat.getPreferenceCount() <= 0)
+			{
+				cursor.moveToFirst();
+				selectedCat.addPreference(MythMotePreferences
+						.createSelectedLocationPreference(context, context
+								.getString(R.string.selected_location_str),
+								cursor.getString(_nameIndex)));
+
+				// save location ID so that it is for real
+				SaveSelectedLocationId(context, cursor.getInt(_idIndex));
+			}
+		} else
+		{
+			selectedCat
+					.addPreference(MythMotePreferences.createSelectedLocationPreference(
+							context,
+							context.getString(R.string.selected_location_str),
+							context.getString(R.string.no_frontend_locations_defined_str)));
+		}
+
+		cursor.close();
+		_dbAdapter.close();
+
+		// set preference screen
 		context.setPreferenceScreen(prefScreen);
 	}
 
-	private static void showLocationEditDialog(Activity context, FrontendLocation location)
+	private static void showLocationEditDialog(Activity context,
+			FrontendLocation location)
 	{
-		Intent intent = new Intent(context, tkj.android.homecontrol.mythmote.LocationEditor.class);
-		
-		//put extra information is needed
-		if(location != null)
+		Intent intent = new Intent(context,
+				tkj.android.homecontrol.mythmote.LocationEditor.class);
+
+		// put extra information is needed
+		if (location != null)
 		{
 			intent.putExtra(FrontendLocation.STR_ID, location.ID);
 			intent.putExtra(FrontendLocation.STR_NAME, location.Name);
 			intent.putExtra(FrontendLocation.STR_ADDRESS, location.Address);
 			intent.putExtra(FrontendLocation.STR_PORT, location.Port);
 		}
-		
-		//start activity
+
+		// start activity
 		context.startActivity(intent);
 	}
-	
-	private static void showDeleteLocationList(final Activity context) 
+
+	private static void showDeleteLocationList(final Activity context)
 	{
-		final LocationDbAdapter _dbAdapter = new LocationDbAdapter(context);
+		final MythMoteDbManager _dbAdapter = new MythMoteDbManager(context);
 		_dbAdapter.open();
 		final Cursor cursor = _dbAdapter.fetchAllFrontendLocations();
-        
-        int count = cursor.getCount();
-        if(count > 0 && cursor.moveToFirst())
-        {
-        	final String[] names = new String[count];
-        	final int[] ids = new int[count];
-        	for(int i=0; i<count; i++)
-        	{
-        		names[i] = cursor.getString(cursor.getColumnIndex(LocationDbAdapter.KEY_NAME));
-        		ids[i] = cursor.getInt(cursor.getColumnIndex(LocationDbAdapter.KEY_ROWID));
-        		cursor.moveToNext();
-        	}
-        	
-        	AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        	builder.setTitle(R.string.delete_location_str);
-        	builder.setItems(names, new DialogInterface.OnClickListener(){
 
-        		public void onClick(DialogInterface dialog,
-        				int which) {
-        			LocationDbAdapter dbAdapter = new LocationDbAdapter(context);
-        			dbAdapter.open();
-        			dbAdapter.deleteFrontendLocation(ids[which]);
-        			dbAdapter.close();
-        			
-        			setupPreferences((PreferenceActivity)context);
-        		}
+		int count = cursor.getCount();
+		if (count > 0 && cursor.moveToFirst())
+		{
+			final String[] names = new String[count];
+			final int[] ids = new int[count];
+			for (int i = 0; i < count; i++)
+			{
+				names[i] = cursor.getString(cursor
+						.getColumnIndex(MythMoteDbHelper.KEY_NAME));
+				ids[i] = cursor.getInt(cursor
+						.getColumnIndex(MythMoteDbHelper.KEY_ROWID));
+				cursor.moveToNext();
+			}
 
-				});
-        	builder.show();
-        }
+			AlertDialog.Builder builder = new AlertDialog.Builder(context);
+			builder.setTitle(R.string.delete_location_str);
+			builder.setItems(names, new DialogInterface.OnClickListener()
+			{
+
+				public void onClick(DialogInterface dialog, int which)
+				{
+					MythMoteDbManager dbAdapter = new MythMoteDbManager(context);
+					dbAdapter.open();
+					dbAdapter.deleteFrontendLocation(ids[which]);
+					dbAdapter.close();
+
+					setupPreferences((PreferenceActivity) context);
+				}
+
+			});
+			builder.show();
+		}
 		cursor.close();
-        _dbAdapter.close();
+		_dbAdapter.close();
 	}
-	
-	private static CheckBoxPreference createCheckBox(Context context, String key, int title, int summary, Object defaultValue)
+
+	private static CheckBoxPreference createCheckBox(Context context,
+			String key, int title, int summary, Object defaultValue)
 	{
 		CheckBoxPreference pref = new CheckBoxPreference(context);
-        pref.setKey(key);
-        pref.setDefaultValue(defaultValue);
-        pref.setTitle(title);
-        pref.setSummary(summary);
-        pref.setPersistent(true);
-        return pref;
+		pref.setKey(key);
+		pref.setDefaultValue(defaultValue);
+		pref.setTitle(title);
+		pref.setSummary(summary);
+		pref.setPersistent(true);
+		return pref;
 	}
-	
-	private static Preference createLocationPreference(final Activity context, String key, String name, String value)
+
+	private static Preference createLocationPreference(final Activity context,
+			String key, String name, String value)
 	{
 		Preference pref = new Preference(context);
 		pref.setKey(key);
@@ -271,26 +281,28 @@
 		pref.setDefaultValue(value);
 		pref.setEnabled(true);
 		pref.setSummary(value);
-		pref.setOnPreferenceClickListener(new OnPreferenceClickListener(){
+		pref.setOnPreferenceClickListener(new OnPreferenceClickListener()
+		{
 
-			public boolean onPreferenceClick(Preference preference) {
-				//Open location edit dialog with a location loaded
+			public boolean onPreferenceClick(Preference preference)
+			{
+				// Open location edit dialog with a location loaded
 				FrontendLocation location = new FrontendLocation();
-				
-				
+
 				location.ID = Integer.parseInt(preference.getKey());
-				
-				LocationDbAdapter dbAdapter = new LocationDbAdapter(context);
+
+				MythMoteDbManager dbAdapter = new MythMoteDbManager(context);
 				dbAdapter.open();
 				Cursor cursor = dbAdapter.fetchFrontendLocation(location.ID);
-				
-				//get column indexes 
-		        _idIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_ROWID);
-		        _addressIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_ADDRESS);
-		        _nameIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_NAME);
-		        _portIndex = cursor.getColumnIndex(LocationDbAdapter.KEY_PORT);
-				
-				if(cursor != null && cursor.getCount() > 0)
+
+				// get column indexes
+				_idIndex = cursor.getColumnIndex(MythMoteDbHelper.KEY_ROWID);
+				_addressIndex = cursor
+						.getColumnIndex(MythMoteDbHelper.KEY_ADDRESS);
+				_nameIndex = cursor.getColumnIndex(MythMoteDbHelper.KEY_NAME);
+				_portIndex = cursor.getColumnIndex(MythMoteDbHelper.KEY_PORT);
+
+				if (cursor != null && cursor.getCount() > 0)
 				{
 					location.Name = cursor.getString(_nameIndex);
 					location.Address = cursor.getString(_addressIndex);
@@ -299,12 +311,13 @@
 				}
 				return false;
 			}
-			
+
 		});
 		return pref;
 	}
-	
-	private static Preference createAddLocationPreference(final Activity context, String name, String value)
+
+	private static Preference createAddLocationPreference(
+			final Activity context, String name, String value)
 	{
 		Preference pref = new Preference(context);
 		pref.setKey(name);
@@ -312,20 +325,23 @@
 		pref.setDefaultValue(value);
 		pref.setEnabled(true);
 		pref.setSummary(value);
-		pref.setOnPreferenceClickListener(new OnPreferenceClickListener(){
+		pref.setOnPreferenceClickListener(new OnPreferenceClickListener()
+		{
 
-			public boolean onPreferenceClick(Preference preference) {
-				
+			public boolean onPreferenceClick(Preference preference)
+			{
+
 				showLocationEditDialog(context, null);
-				
+
 				return false;
 			}
-			
+
 		});
 		return pref;
 	}
-	
-	private static Preference createDeleteLocationPreference(final Activity context, String name, String value)
+
+	private static Preference createDeleteLocationPreference(
+			final Activity context, String name, String value)
 	{
 		Preference pref = new Preference(context);
 		pref.setKey(name);
@@ -333,18 +349,21 @@
 		pref.setDefaultValue(value);
 		pref.setEnabled(true);
 		pref.setSummary(value);
-		pref.setOnPreferenceClickListener(new OnPreferenceClickListener(){
+		pref.setOnPreferenceClickListener(new OnPreferenceClickListener()
+		{
 
-			public boolean onPreferenceClick(Preference preference) {				
+			public boolean onPreferenceClick(Preference preference)
+			{
 				showDeleteLocationList(context);
 				return false;
 			}
-			
+
 		});
 		return pref;
 	}
-	
-	private static Preference createSelectedLocationPreference(final PreferenceActivity context, String name, String value)
+
+	private static Preference createSelectedLocationPreference(
+			final PreferenceActivity context, String name, String value)
 	{
 		Preference pref = new Preference(context);
 		pref.setKey(name);
@@ -352,17 +371,21 @@
 		pref.setDefaultValue(value);
 		pref.setEnabled(true);
 		pref.setSummary(value);
-		pref.setOnPreferenceClickListener(new OnPreferenceClickListener(){
+		pref.setOnPreferenceClickListener(new OnPreferenceClickListener()
+		{
 
-			public boolean onPreferenceClick(Preference preference) {
-				
-				//Displays the list of configured frontend locations.
-				//Fires the locationChanged event when the user selects a location
-				//even if the user selects the same location already selected.
+			public boolean onPreferenceClick(Preference preference)
+			{
+
+				// Displays the list of configured frontend locations.
+				// Fires the locationChanged event when the user selects a
+				// location
+				// even if the user selects the same location already selected.
 				SelectLocation(context, new LocationChangedEventListener()
 				{
-					public void LocationChanged() {
-						//reset preference list with updated selection
+					public void LocationChanged()
+					{
+						// reset preference list with updated selection
 						setupPreferences(context);
 					}
 
@@ -372,48 +395,54 @@
 		});
 		return pref;
 	}
-	
-	public static void SelectLocation(final Activity context, final LocationChangedEventListener listener)
+
+	public static void SelectLocation(final Activity context,
+			final LocationChangedEventListener listener)
 	{
-		LocationDbAdapter _dbAdapter = new LocationDbAdapter(context);
+		MythMoteDbManager _dbAdapter = new MythMoteDbManager(context);
 		_dbAdapter.open();
 		final Cursor cursor = _dbAdapter.fetchAllFrontendLocations();
-        
-        int count = cursor.getCount();
-        if(count > 0 && cursor.moveToFirst())
-        {
-        	final String[] names = new String[count];
-        	final int[] ids = new int[count];
-        	for(int i=0; i<count; i++)
-        	{
-        		names[i] = cursor.getString(cursor.getColumnIndex(LocationDbAdapter.KEY_NAME));
-        		ids[i] = cursor.getInt(cursor.getColumnIndex(LocationDbAdapter.KEY_ROWID));
-        		cursor.moveToNext();
-        	}
-        	
-        	//show list of locations as a single selected list
-        	AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        	builder.setTitle(R.string.select_location_str);
-        	builder.setItems(names, new DialogInterface.OnClickListener(){
 
-        		public void onClick(DialogInterface dialog,
-        				int which) {
-        			
-        			//save selected location
-        			SaveSelectedLocationId(context, ids[which]);
-        			
-        			//notify that we selected a location
-        			listener.LocationChanged();
-        		}});
-        	builder.show();
-        }
+		int count = cursor.getCount();
+		if (count > 0 && cursor.moveToFirst())
+		{
+			final String[] names = new String[count];
+			final int[] ids = new int[count];
+			for (int i = 0; i < count; i++)
+			{
+				names[i] = cursor.getString(cursor
+						.getColumnIndex(MythMoteDbHelper.KEY_NAME));
+				ids[i] = cursor.getInt(cursor
+						.getColumnIndex(MythMoteDbHelper.KEY_ROWID));
+				cursor.moveToNext();
+			}
+
+			// show list of locations as a single selected list
+			AlertDialog.Builder builder = new AlertDialog.Builder(context);
+			builder.setTitle(R.string.select_location_str);
+			builder.setItems(names, new DialogInterface.OnClickListener()
+			{
+
+				public void onClick(DialogInterface dialog, int which)
+				{
+
+					// save selected location
+					SaveSelectedLocationId(context, ids[which]);
+
+					// notify that we selected a location
+					listener.LocationChanged();
+				}
+			});
+			builder.show();
+		}
 		cursor.close();
-        _dbAdapter.close();
+		_dbAdapter.close();
 	}
-	
+
 	private static void SaveSelectedLocationId(Activity context, int id)
 	{
-		SharedPreferences settings = context.getSharedPreferences(MYTHMOTE_SHARED_PREFERENCES_ID, MODE_PRIVATE);
+		SharedPreferences settings = context.getSharedPreferences(
+				MYTHMOTE_SHARED_PREFERENCES_ID, MODE_PRIVATE);
 		SharedPreferences.Editor editor = settings.edit();
 		editor.putInt(MythMotePreferences.PREF_SELECTED_LOCATION, id);
 		editor.commit();
Index: src/tkj/android/homecontrol/mythmote/LocationChangedEventListener.java
===================================================================
--- src/tkj/android/homecontrol/mythmote/LocationChangedEventListener.java	(revision 129)
+++ src/tkj/android/homecontrol/mythmote/LocationChangedEventListener.java	(working copy)
@@ -3,8 +3,9 @@
 import java.util.EventListener;
 
 /**  **/
-public interface LocationChangedEventListener extends EventListener {
-	
+public interface LocationChangedEventListener extends EventListener
+{
+
 	public void LocationChanged();
-	
+
 }
